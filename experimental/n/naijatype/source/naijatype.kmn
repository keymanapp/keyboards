c Physical keyboard uses ; key to transform.
c Touch keyboard uses long press on related letters.
c Comma to left of space bar + Emoji. Removed capitals on long press default keyboard.
c Note we need to output K_ keys on punctuation with appropriate modifier keys held down to make sure the key runs through the Keyman Layout rules and converts space + ? into ? + space. This makes it handle the automatic space put in at the end of predictive texting better.
c 
c Added small capital I.
c Restored the globe language menu but moved it left.
c Custom CSS styling to try to match the less cluttered Google look.
c Added / to punctuation. Stopped . doing shift until after a space.
c Added more language codes
c Fixed JDM issues: not changing to default after some longpress shift letters.
c Styling for iOS added.
c v26 Added nasal vowels in touch
c v27 Added languages
c v28 Added ʉɄ option for 10 vowel languages and did a major overhaul of the whole physical keyboard so that it rotates between single character and combining underlined/underdotted reliably.
c v29 Corrected oversight (bug) which didn't allow tone on underline and underdot letters.
store(&VERSION) '9.0'
store(&NAME) 'Naija Type'
store(&TARGETS) 'any windows macosx linux web iphone ipad androidphone androidtablet mobile desktop tablet'
store(&ETHNOLOGUECODE) 'eng hau ibo yor ahs png fuv ldb yes bqv'
store(&WINDOWSLANGUAGES) 'x0468 x0470 x046A'
store(&LANGUAGE) 'x0468'
store(&LAYOUTFILE) 'naijatype-layout.js'
store(&COPYRIGHT) '© David Rowbory 2021 Free to distribute under licence CC-BY-SA'
store(&BITMAP) 'naijatype.ico'
store(&KMW_HELPFILE) 'naijatype-help.htm'
store(&MESSAGE) 'Inspired by prior work by Heidi Rosendall and Andy Kellogg'
store(&KMW_HELPTEXT) 'Type common Nigerian language letters and the ₦ sign'
store(&KEYBOARDVERSION) '29'
store(&KMW_EMBEDCSS) 'naijatype.css'


c Rota system originally designed by Andy Kellogg and reimplemented by David Rowbory
c   Concept: 
c       Start with the normal letters, then a trigger key is pressed:
c       Lookup char in LtrsSET1. Position p.
c       Swap for the letter at position p in LtrsSET2.
c           If LtrsSET2(p)=LtrsSET1(p+1) then we have a back-forth rota.
c       But we can manage a longer rota by arranging a chain where the first letter of 
c       the sequence is bumped to the end of the second.
c           LtrsSET1: abcde
c           LtrsSET2: bcdea
c We use a LibreOffice doc to calculate this and show the rotations.
c 
c All this is very well but the lookup and switch only works
c if we are replacing SINGLE unicode characters, not the double
c (combining) underline and underdot.
c For those we need to do something different. 
c If we wanted underline and underdot to be the first change then we could
c just do them first, but we want to do the other shape changes first, and only
c move onto underlines when we have exhausted the other shape changes.
c 
c So we first check for an underline and change it to a dot.
c If dot then we remove dot.
c If neither underline or underdot are found then we need to change shape 
c working through a rota.
c When we get to the last shape in the rota, then we change to an underline of the base letter.

c Action keys
store(LtrsKey)        ";"         c if changed, you have to manually change method for typing this control key
store(ToneKey)        "`"         c if changed, you have to manually change method for typing this control key
store(NasalKey)       "~" c U+00AC c if changed, you have to manually change method for typing this control key

c These stores generated by the naijatype_key_generator.ods file				
store(LtrsSET1)	"aəeɛiɨɪoɔuʊʉbɓcçdɗgɣhɦkƙnŋɲsʃvⱱyƴzʒ$₦£ˈAƏEƐIƗƗOƆUƱɄBƁCÇDƊGƔHꞪKƘNŊƝSƩVƲYƳZƷ$₦£ˈ"			
store(LtrsSET2)	"əaɛeɨɪiɔoʊʉuɓbçcɗdɣgɦhƙkŋɲnʃsⱱvƴyʒz₦£ˈ$ƏAƐEƗƗIƆOƱɄUƁBÇCƊDƔGꞪHƘKŊƝNƩSƲVƳYƷZ₦£ˈ$"			
store(LtrsUnderlinable)	"aeiouhnsAEIOUHNS"			c <------ this is manually entered
store(LtrsUnderlineAfter)	"əɛɪɔʉɦɲʃƏƐƗƆɄꞪƝƩ"			

c This is only specified here
store(UnderLine)  U+0331
store(UnderDot) U+0323
store(LtrsWithTone)   "qaəeɛiɨɪoɔuʉʊnQAƏEƐIƗOƆɄUƱmnŋɲMNŊƝ" outs(UnderLine) outs(UnderDot)
store(LtrsWithNasal)  "qaəeɛiɨɪoɔuʉʊnQAƏEƐIƗOƆɄUƱN" outs(UnderLine) outs(UnderDot)
store(Tone1st)  U+301   c Hi / acute
store(ToneLast) U+304   c Mid / bar
store(ToneCore)     U+0300 U+0302 U+030C    c Low, Falling, Rising
store(ToneRota1)    outs(Tone1st) outs(ToneCore)
store(ToneRota2)     outs(ToneCore) outs(ToneLast)    c And the final tone mark added, Special rules for these below.
store(ToneSubset)     outs(ToneRota1) U+0304    c All the tones
store(TonesAll)                outs(ToneSubset) U+030B U+030F U+1DC4 U+1DC5 U+1DC6 U+1DC7


begin Unicode > use(main)

group(main) using keys
store(changeshape) '1' c ie default to changing shape
store(canunderline) '0' c ie can't underline

c Bugfix July 2021 these lines added to reset the state when backspace happens otherwise wrong changes are made
U+0331 + [K_BKSP] > nul set(changeshape='1')
U+0323 + [K_BKSP] > nul set(changeshape='1')
any(LtrsSET1) + [K_BKSP] > nul set(changeshape='1')

c Special Ways to Type Select Special Letters Directly (Mac users appreciate this)
+ [CTRL ALT K_Y] > 'ƴ'
+ [CTRL ALT K_K] > 'ƙ'
+ [CTRL ALT K_B] > 'ɓ'
+ [CTRL ALT K_D] > 'ɗ'
+ [CTRL ALT K_N] > 'ŋ'
+ [CTRL ALT K_O] > 'ɔ'
+ [CTRL ALT K_I] > 'ɨ'
+ [CTRL ALT K_U] > 'ʊ'
+ [CTRL ALT K_E] > 'ɛ'
+ [CTRL ALT K_A] > 'ə'
+ [CTRL ALT SHIFT K_Y] > 'Ƴ'
+ [CTRL ALT SHIFT K_K] > 'Ƙ'
+ [CTRL ALT SHIFT K_B] > 'Ɓ'
+ [CTRL ALT SHIFT K_D] > 'Ɗ'
+ [CTRL ALT SHIFT K_N] > 'Ŋ'
+ [CTRL ALT SHIFT K_O] > 'Ɔ'
+ [CTRL ALT SHIFT K_I] > 'Ɨ'
+ [CTRL ALT SHIFT K_U] > 'Ʊ'
+ [CTRL ALT SHIFT K_E] > 'Ɛ'
+ [CTRL ALT SHIFT K_A] > 'Ə'
c Use alt+semicolon to get a real semicolon
+ [ALT K_COLON] > ';'
+ [T_a_underline] > 'a̱'
+ [T_e_underline] > 'e̱'
+ [T_i_underline] > 'i̱'
+ [T_o_underline] > 'o̱'
+ [T_u_underline] > 'u̱'
+ [T_a_underdot] > 'ạ'
+ [T_e_underdot] > 'ẹ'
+ [T_i_underdot] > 'ị'
+ [T_o_underdot] >  'ọ'
+ [T_u_underdot] > 'ụ'
+ [T_n_underdot] > 'ṇ'
+ [T_n_underline] > 'n' U+0331
+ [T_h_underdot] > 'ḥ'
+ [T_a_underline] > 'a̱'
+ [T_e_underline] > 'e̱'
+ [T_i_underline] > 'i̱'
+ [T_o_underline] > 'o̱'
+ [T_u_underline] > 'u̱'
+ [T_a_underdot] > 'ạ'
+ [T_e_underdot] > 'ẹ'
+ [T_i_underdot] > 'ị'
+ [T_o_underdot] >  'ọ'
+ [T_u_underdot] > 'ụ'
+ [T_ucA_underline] > 'A̱'
+ [T_ucE_underline] > 'E̱'
+ [T_ucI_underline] > 'I̱'
+ [T_ucO_underline] > 'O̱'
+ [T_ucU_underline] > 'U̱'
+ [T_ucA_underdot] > 'Ạ'
+ [T_ucE_underdot] > 'Ẹ'
+ [T_ucI_underdot] > 'Ị'
+ [T_ucO_underdot] > 'Ọ'
+ [T_ucU_underdot] > 'Ụ'
+ [T_ucN_underdot] > 'Ṇ'
+ [T_ucN_underline] > 'N' U+0331
+ [T_ucH_underdot] > 'Ḥ'
+ [T_n_bar] > 'n' U+0304
+ [T_ucN_bar] > 'N' U+0304
+ [T_q_acute] > 'q' U+0301
+ [T_q_grave] > 'q' U+0300
+ [T_q_nasal] > 'q' U+0303
+ [T_ucQ_acute] > 'Q' U+0301
+ [T_ucQ_grave] > 'Q' U+0300
+ [T_ucQ_nasal] > 'Q' U+0303
+ [T_end_sentence] > '. '

c nasals from touch layout
+ [T_a_nasal] > 'a' U+0303
+ [T_A_nasal] > 'A' U+0303
+ [T_a2_nasal] > 'ə' U+0303
+ [T_A2_nasal] > 'Ə' U+0303
+ [T_e_nasal] > 'e' U+0303
+ [T_E_nasal] > 'E' U+0303
+ [T_e2_nasal] > 'ɛ' U+0303
+ [T_E2_nasal] > 'Ɛ' U+0303
+ [T_i_nasal] > 'i' U+0303
+ [T_I_nasal] > 'I' U+0303
+ [T_i2_nasal] > 'ɨ' U+0303
+ [T_I2_nasal] > 'Ɨ' U+0303
+ [T_u_nasal] > 'u' U+0303
+ [T_U_nasal] > 'U' U+0303
+ [T_o_nasal] > 'o' U+0303
+ [T_O_nasal] > 'O' U+0303
+ [T_o2_nasal] > 'ɔ' U+0303
+ [T_O2_nasal] > 'Ɔ' U+0303


c Moved letter substitution from here, since it needs to happen last

c Tone Rota
any(LtrsWithTone) + any(ToneKey) > context U+0301   c Start tone
any(ToneRota1) + any(ToneKey) > index(ToneRota2,1)  c Move to next tone letter
U+0304 + any(ToneKey) > nul     c Remove tone after we use the last tone letter
U+0303 + any(ToneKey) > context U+0301    c it is assumed that if a letter has nasal it can have tone

c Nasal Toggle
any(LtrsWithNasal) + any(NasalKey) > context U+0303
U+0303 + any(NasalKey) > nul
U+0303 any(ToneSubset) + any(NasalKey) > index(ToneSubset, 2)
any(LtrsWithNasal) any(ToneSubset) + any(NasalKey) > index(LtrsWithNasal, 1) U+0303 index(ToneSubset,2)

c Added double space for end of sentence and remove spaces before , . ? !
c Auto-shift layer when we type an end of sentence
U+0020 + U+0020 > '. ' layer("shift")
U+0020 + '.' > '. ' layer("shift")
U+0020 + ',' > ', '
U+0020 + U+003f > '? ' layer("shift")
U+0020 + U+0021 > '! ' layer("shift")
U+0020 + '?' > '? ' layer("shift")
U+0020 + '!' > '! ' layer("shift")
'.' + U+0020 > '. ' layer("shift") c For touch, so we can avoid switching to shift during URLs 
'.' + [K_ENTER] > '.' U+0010 layer("shift") 
c Change shift layer when we backspace, eg space-space then backspace backspace.
c Remove shift layer when we delete something that may have caused it to be turned on.
c This may be unhelpful if we had shift or caps on before, but that seems unlikely.
'.'+ [K_BKSP] > nul layer("default")
'!'+ [K_BKSP] > nul layer("default")
'?'+ [K_BKSP] > nul layer("default")

c Shift when we backspace to end of sentence.
'. '+ [K_BKSP] > '.' layer("shift")
'! '+ [K_BKSP] > '!' layer("shift")
'? '+ [K_BKSP] > '?' layer("shift")

c Emojis
+ [T_thumbs_up] > U+1F44D U+1F3FE
+ [T_hands_together] > U+1F64F U+1F3FE

c Literal escapes -- ie type the actual keys that do the magic.
c IMPORTANT: This has only been tested on US Keyboards
+ [ALT K_COLON]         > ";"
+ [ALT K_BKQUOTE]       > "`"
+ [ALT SHIFT K_BKQUOTE] > "~"

c Make Control Keys Do Nothing Unless with Special Context
+ any(LtrsKey)  > ';'       c was null, but changed to output the normal character - 2021
+ any(ToneKey)  > '`'
+ any(NasalKey) > '~'

c Letter Modifications
c
c if we have an underline then change to a dot and update what rules we will follow
U+0331 + any(LtrsKey) > U+0323
c if we have an underdot then remove it and get ready to change shape
U+0323 + any(LtrsKey) > nul  c underdot to change shape once and next shape change will switch to underline

c we used to have some complicated rules here, but we don't need the 
any(LtrsUnderlineAfter) + any(LtrsKey) > index(LtrsUnderlinable, 1) U+0331  c change shape next 
any(LtrsSET1) + any(LtrsKey) > index(LtrsSET2, 1)


c REMOVED THESE CHANGE-LETTERS-UNDER-DIACRITIC sections. unclear whether we need them.
c Change a Letter from under Tone and Nasal
c NOTE: These need to be hard-coded since Keyman
c cannot handle 2+ any() functions in the context
c any(LtrsCURRENT) U+0303 U+0300 + any(LtrsKey) > index(LtrsCHANGED, 1) U+0303 U+0300
c any(LtrsCURRENT) U+0303 U+0301 + any(LtrsKey) > index(LtrsCHANGED, 1) U+0303 U+0301
c any(LtrsCURRENT) U+0303 U+0302 + any(LtrsKey) > index(LtrsCHANGED, 1) U+0303 U+0302
c any(LtrsCURRENT) U+0303 U+030C + any(LtrsKey) > index(LtrsCHANGED, 1) U+0303 U+030C
c any(LtrsCURRENT) U+0303 U+0304 + any(LtrsKey) > index(LtrsCHANGED, 1) U+0303 U+0304

c NOTE: Letters with only tone need to be hard-coded since Keyman
c cannot handle 2+ any() functions in the contextc any(LtrsWithNasal) U+0300 + any(NasalKey) > index(LtrsWithNasal, 1) U+0303 U+0300
c any(LtrsWithNasal) U+0301 + any(NasalKey) > index(LtrsWithNasal, 1) U+0303 U+0301
c any(LtrsWithNasal) U+0302 + any(NasalKey) > index(LtrsWithNasal, 1) U+0303 U+0302
c any(LtrsWithNasal) U+030C + any(NasalKey) > index(LtrsWithNasal, 1) U+0303 U+030C
c any(LtrsWithNasal) U+0304 + any(NasalKey) > index(LtrsWithNasal, 1) U+0303 U+0304


c U+0301 + any(ToneKey) > U+0300
c U+0300 + any(ToneKey) > U+0302
c U+0302 + any(ToneKey) > U+030C
c U+030C + any(ToneKey) > U+0304
c U+0304 + any(ToneKey) > nul
c Change a Letter from under Tone
c NOTE: These need to be hard-coded since Keyman
c cannot handle 2+ any() functions in the context
c any(LtrsCURRENT) U+0300 + any(LtrsKey) > index(LtrsCHANGED, 1) U+0300
c any(LtrsCURRENT) U+0301 + any(LtrsKey) > index(LtrsCHANGED, 1) U+0301
c any(LtrsCURRENT) U+0302 + any(LtrsKey) > index(LtrsCHANGED, 1) U+0302
c any(LtrsCURRENT) U+030C + any(LtrsKey) > index(LtrsCHANGED, 1) U+030C
c any(LtrsCURRENT) U+0304 + any(LtrsKey) > index(LtrsCHANGED, 1) U+0304

c Change a Letter from under Nasal
c IMPORTANT: This needs to follow the Tone and Nasal grouping
c any(LtrsCURRENT) U+0303 + any(LtrsKey) > index(LtrsCHANGED, 1) U+0303

c ---------------------------------------------------------------------------

c OLD CODE THAT WILL BE REMOVED COMPLETELY IN LATER VERSIONS
c Dev - removed from top
c store(LtrsSET1orig)       "aəeɛiɨoɔuʊbɓcçdɗgɣhɦkƙnŋsʃvⱱyƴzʒAƏEƐIƗOƆUƱBƁCÇDƊGƔKƘNŊSƩVƲYƳZƷ$₦£?ˈ" c no capital "hooktop h"
c store(LtrsSET2orig)       "əaɛəɨiɔoʊuɓbçcɗdɣgɦhƙkŋnʃsⱱvƴyʒzƏAƐEƗIƆOƱUƁBÇCƊDƔGƘGŊNƩSƲVƳYƷZ₦£$ˈ?" c no capital "hooktop h"
c store(LtrsSET3)       "aəeɛiɨoɔʉʊbɓcçdɗgɣhɦkƙnŋsʃvⱱyƴzʒAƏEƐIƗOƆɄƱBƁCÇDƊGƔKƘNŊSƩVƲYƳZƷ$₦£?ˈ" c no capital "hooktop h"
c store(rota3)       "aəa̱ạa|eɛe̱ẹe|iɨi|oɔo|uʉʊu|bɓbcçdɗgɣhɦkƙnŋsʃvⱱyƴzʒAƏEƐIƗOƆɄƱBƁCÇDƊGƔKƘNŊSƩVƲYƳZƷ$₦£?ˈ" c no capital "hooktop h"
c store(rota2)       "əa|ɨi|ɔo|ʉʊu|ɓbcçdɗgɣhɦkƙnŋsʃvⱱyƴzʒAƏEƐIƗOƆɄƱBƁCÇDƊGƔKƘNŊSƩVƲYƳZƷ$₦£?ˈ" c no capital "hooktop h"
c store(rota)       "aə|iɨi|oɔo|uʉʊu|bɓbcçdɗgɣhɦkƙnŋsʃvⱱyƴzʒAƏEƐIƗOƆɄƱBƁCÇDƊGƔKƘNŊSƩVƲYƳZƷ$₦£?ˈ" c no capital "hooktop h"
c store(voweldks)   dk(a) dk(e)
c store(trig2) '*'
c dk(a) + any(LtrsKey) > 'a' U+331
c dk(e) + any(LtrsKey) > 'e' U+331
c dk(i) + any(LtrsKey) > 'i' U+331
c dk(o) + any(LtrsKey) > 'a' U+331
c dk(u) + any(LtrsKey) > 'u' U+331
c any(LtrsSET1) + any(LtrsKey) > index(LtrsSET2,1) dk(a)


c REMOVED FROM ABOVE THE GROUPS
c any(LtrsUnderlinable) + any(LtrsKey) > context set(canunderline='1')
c if (canunderline='0') + any(LtrsKey) > set(changeshape='1') c Override to require changing shape if we can't underline (or dot) here.

c if (changeshape='3') + any(LtrsKey) > use(changeShapeRules3) c any(LtrsCURRENT) + any(LtrsKey) > index(LtrsCHANGED, 1)



c at the end
c group(changeShapeRules3) using keys c 3rd shape change adds automatic underline
c    	any(LtrsSET2) + any(LtrsKey) > index(LtrsSET3, 1) U+0331 set(changeshape='0')    c underline is next

