c Taang Keyboard for Unicode Encoding. 
c Derived from an original by MJP Hosken (SIL)
c 
c This Layout has been designed to resemble that used by WinMyanmar Systems, 
c however, it is much simplified because of the advantages of Unicode
c technology. Some keys have changed as a result.

store(&VERSION) '10.0'
store(&KEYBOARDVERSION) '1.2'
store(&NAME) 'SIL Taang'
c Comment out the line below to compile for SCIM
store(&COPYRIGHT) "© SIL Global"

c BITMAP Taang
c HOTKEY "^+W"
store(&TARGETS) 'desktop'

begin Unicode > use(Main)
c qwertyuiop[ is same as Win
c asdfghjkl; is same as Win
c zxcvbm is same as Win      
c currently _ is mapped to * but it is multiply in Win
c , is U101A in both Win and here. ',' is < here    
c in Win 'P' is U100F, here at 'E' - Win's E is not needed anymore
c W is now U101D - the symbol in Win at this position is not used
c and includes U101D anyway
c Duplicates/macros that aren't strictly necessary EKL:F$| 
c The medials are also can be created using stacking: GjsS
c Pali characters that might need a location: U1050-1059
c Some of the characters <.}]^ could be changed to make room
c Should U101B, U1002 be moved somewhere more accessible e.g. R,U rather than &,*?
store(baseK)    'qwertyui' \
                "op['zxc"  \
                'vbn,./' \
                'QWERTY' \
                'UIOP{A"' \
                'ZXCVBNM?' \
                '-=!@#^&' \
                '*()|' \
                '\]}<>`~'
                
store(baseU)    U+1006 U+1010 U+1014 U+1019 U+1021 U+1015 U+1000 U+1004 \
                U+101E U+1005 U+101F U+0027 U+1016 U+1011 U+1001 \
                U+101C U+1018 U+100A U+101A U+002E U+104B \
                U+1029 U+101D U+105A U+1023 U+108F U+104C \
                U+1009 U+108E U+1025 U+100F U+005B U+1017 U+0022 \
                U+1007 U+100C U+1003 U+1020 U+1026 U+1008 U+104E U+104A \
                U+002D U+003D U+100D U+100E U+100B U+1028 U+101B \
                U+1002 U+0028 U+0029 U+105B \
                U+104F U+1012 U+005D U+1087 U+1088 U+25CC U+2060     
                
store(numK)     '1234567890' 
store(numU)     U+1041 U+1042 U+1043 U+1044 U+1045 U+1046 U+1047 U+1048 U+1049 \
                U+1040                
                
c 'm' is a duplicate of 'g' 
store(aftereK)  'mgh;'
store(aftereU)  U+102C U+102B U+1037 U+1038

c sub units of aftereK
store (aaK)     'mg'
store (aaU)     U+102C U+102B
store (lDotK)   'h'
store (lDotU)   U+1037
store (visargaK) ';'
store (visargaU) U+1038
                      
store(udiaK)    'dDJKL'
store(udiaU)    U+102D U+102E U+1032 U+1034 U+1033
                  
store(lodiaK)   'kl'
store(lodiaU)   U+102F U+1030

store(aftereDK) 'f'
store(aftereDU) U+103A               

c 25cc is added here to allow it to be used to show stand alone diacritics
store(consU)    U+1000 U+1001 U+1002 U+1003        U+1005 U+1006 U+1007 \
                U+1008 U+1009 U+100A U+100B U+100C U+100D U+100E U+100F \
                U+1010 U+1011 U+1012 U+1013 U+1014 U+1015 U+1016 U+1017 \
                U+1018 U+1019 U+101A U+101B U+101C U+101D U+101E U+101F \
                U+1020 U+1021 U+25CC


store(sdiaK)     'sjSG$%'
store(sdiaU)     U+103B U+103C U+103E U+103D U+105E U+105F
store(diaU)      outs(sdiaU) outs(udiaU) outs(lodiaU) U+1031 U+1036

c this is a weired stacked combination of 100B,100C                      
store(ttatthaK) '|'    
    
c split up diacritics - user shouldn't need to know canonical order 
c Y/R should be first and can't come together               
store(yDiaU)    U+103B
store(rDiaU)    U+103C
store(lDiaU)    U+1060
store(wDiaU)    U+103D 
store(hDiaU)    U+103E

store(m1DiaK)   's'
store(m2DiaK)   'sj'
store(m3DiaK)   'sj_'
store(m4DiaK)   'sj_G'
store(m5DiaK)   'sj_GS'
store(mDia)     U+103B U+103C U+1060 U+103D U+103E

store(filler)   U+200B
          
c F is Kinzi - it should be possible to create a Kinzi   
store(kinziK)   'F'
store(kinziU)   U+1004    

store(vowelEK)  'a'
store(vowelEU)  U+1031  

c create some classes for diacritics that might have been 
c sensibly typed before the user types the medial
store(allDiaU)  U+1031 U+102F U+1030 U+102D U+1032 U+1036 U+1037
c only a subset can correctly occur together  
c (U+1031 U+1037) (U+102D U+102F) 
c (U+102F U+1036) (U+1032 U+1037) (U+102D U+1036)
store(firstDiaU) U+1031 U+102D U+102F U+1032 
store(secondDiaU) U+102F U+1036 U+1037    
c It is possible for U+102F U+102D U+1037 to occur,
c but in this case its fairly obvious to type the medials
c before the final U+1037    

store(stackK)   '`'
store(stackU)   U+1039


group(Main) using keys

c Deal with vowel E before consonant 
+ any(vowelEK) > outs(filler) outs(vowelEU)           
c stacker key
U+101E U+101E + any(stackK) > U+103F
any(consU) + any(stackK) > outs(stackU) index(consU, 1)  
c rearrange vowel E to behind consonant in stacking situation
U+1031 U+101E U+101E + any(stackK) > U+103F U+1031
U+1031 any(consU) + any(stackK) > outs(stackU) index(consU, 2) U+1031

c modify space keys
 + [SHIFT K_SPACE] > U+200B      
 
c Convert sequences for composite vowels into single code point
U+101E U+1039 U+101B U+1031 + ':' > U+102A
U+101E U+1039 U+101B U+1031 U+102c + any(aftereDK) > U+102A
U+101E + 'j' > U+1029
U+1025 + 'D' > U+1026
 
 + any(numK) > index(numU, 1)     
 + any(baseK) > index(baseU, 1)                         
 + any(aftereK) > index(aftereU, 1)
any(filler) U+1031 + any(baseK) > index(baseU, 3) U+1031      
c any(filler) U+1031 + any(baseK) > U+1031 U+25CC index(baseU, 3) 

c these allow the user to type upper and lower diacritics in
c any order, but to still get the storage right
c any(udiaU) U+1037 + any(lodiaK) > index(lodiaU, 3) context
any(ldiaU) U+1037 + any(udiaK) > index(udiaU, 3) context
U+1037 + any(udiaK) > index(udiaU, 2) context
U+1037 + any(lodiaK) > index(lodiaU, 2) context

 + 'H' > U+1036
U+1036 + any(udiaK) > index(udiaU, 2) context
any(ldiaU) U+1036 + any(udiaK) > index(udiaU, 3) context
U+1036 + any(lodiaK) > index(lodiaU, 2) context
c it is unlikely that other combinations will occur with U1037 
c and aa so this rules are probably OK
U+1037 + any(aaK) > index(aaU, 2) context    
c allow tone marks to be typed in either order
U+1038 + any(lDotK) > index(lDotU, 2) context

c any(udiaU) + any(lodiaK) > index(lodiaU, 2) context
any(ldiaU) + any(udiaK) > index(udiaU, 2) context
 + any(lodiaK) > index(lodiaU, 1)
 + any(udiaK) > index(udiaU, 1)
 
 + ':' > U+102C U+103A
 + '+' > U+002B c U+1063 U+103A
 
c now deal with the medials, need to arrange order appropriately
c most complicated is when all 3 medials are together but out of order 

any(rDiaU) any(lDiaU) any(wDiaU) any(hDiaU) any(firstDiaU) any(secondDiaU) + any(m1DiaK) > index(mDia, 7) context
any(rDiaU) any(lDiaU) any(wDiaU) any(hDiaU) any(firstDiaU) + any(m1DiaK) > index(mDia, 6) context
any(rDiaU) any(lDiaU) any(wDiaU) any(hDiaU) + any(m1DiaK) > index(mDia, 5) context
any(lDiaU) any(wDiaU) any(hDiaU) any(firstDiaU) any(secondDiaU) + any(m2DiaK) > index(mDia, 6) context
any(lDiaU) any(wDiaU) any(hDiaU) any(firstDiaU) + any(m2DiaK) > index(mDia, 5) context
any(lDiaU) any(wDiaU) any(hDiaU) + any(m2DiaK) > index(mDia, 4) context
any(wDiaU) any(hDiaU) any(firstDiaU) any(secondDiaU) + any(m3DiaK) > index(mDia, 5) context
any(wDiaU) any(hDiaU) any(firstDiaU) + any(m3DiaK) > index(mDia, 4) context
any(wDiaU) any(hDiaU) + any(m3DiaK) > index(mDia, 3) context
any(hDiaU) any(firstDiaU) any(secondDiaU) + any(m4DiaK) > index(mDia, 4) context
any(hDiaU) any(firstDiaU) + any(m4DiaK) > index(mDia, 3) context
any(hDiaU) + any(m4DiaK) > index(mDia, 2) context
any(firstDiaU) any(secondDiaU) + any(m5DiaK) > index(mDia, 3) context
any(firstDiaU) + any(m5DiaK) > index(mDia, 2) context
 + any(m5DiaK) > index(mDia, 1) context


any(firstDiaU) any(secondDiaU) + any(sdiaK) > index(sdiaU, 3) context
any(allDiaU) + any(sdiaK) > index(sdiaU, 2) context 

 + any(sdiaK) > index(sdiaU, 1) 
                          
 + any(aftereDK) > index(aftereDU, 1)

any(consU) + any(kinziK) > index(kinziU, 2) U+103A U+1039 context
any(numU) + any(kinziK) > index(kinziU, 2) U+103A U+1039 context
any(consU) U+1039 any(consU) + any(kinziK) > index(kinziU, 4) U+103A U+1039 context
any(consU) U+1039 any(consU) any(diaU) + any(kinziK) > index(kinziU, 5) U+103A U+1039 context
any(consU) U+1039 any(consU) any(diaU) any(diaU) + any(kinziK) > index(kinziU, 6) U+103A U+1039 context
any(consU) any(diaU) + any(kinziK) > index(kinziU, 3) U+103A U+1039 context
any(consU) any(diaU) any(diaU) + any(kinziK) > index(kinziU, 4) U+103A U+1039 context
any(consU) any(diaU) any(diaU) any(diaU) + any(kinziK) > index(kinziU, 5) U+103A U+1039 context
any(consU) any(diaU) any(diaU) any(diaU) any(diaU) + any(kinziK) > index(kinziU, 6) U+103A U+1039 context

any(filler) U+1031 + [K_BKSP] > nul
any(baseU) U+1031 + [K_BKSP] > outs(filler) U+1031

U+1004 U+103A U+1039 any(consU) U+1031 + [K_BKSP] > U+1004 U+103A U+1039 outs(filler) U+1031
U+1039 any(consU) U+1031 + [K_BKSP] > U+1031
U+1039 any(consU) + [K_BKSP] > nul
