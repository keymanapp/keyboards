c BU (BickfordUnicode) keyboard
c Revised: 2005 Nov 13

store(&VERSION)     '10.0'             c Will not work with earlier versions of Keyman.
store(&NAME)        'BU Phonetic'
store(&COPYRIGHT)   '(c) 2006-2020 by Albert Bickford.'
store(&BITMAP) 'bu_phonetic.ico'
store(&HOTKEY)      [CTRL ALT K_U]
store(&MnemonicLayout) "1"



c   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c   * *   IMPORTANT!  READ THIS BEFORE ATTEMPTING TO MODIFY THIS KEYBOARD   * *
c   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

c 1) See the documentation (BUkeys.doc), in the section on Terms of Use, for conditions under which
c    this keyboard may be modified.

c 2) This keyboard supports both Windows ANSI applications (8-bit encoding) as well as Unicode applications.  In 
c     several places in the code below, separate stores need to be set up for ANSI data, and there is a separate 
c     ANSI group that invokes them.  (ANSI-related items have "-A" at the end of their name.)                                                  
c     This means that changes made in the Unicode stores and group, if relevant to an ANSI keyboard, also need to
c     be made in corresponding ANSI stores and the ANSI group, and that both keyboards should be tested independently.

c 3) If you want to modify anything that has to do with saltillo (dotless exclamation) or acute accent,
c    study the code carefully first, as these two are tricky.  Two issues are involved:  
c    a') As of 2006-05-16, saltillo is output using the PUA character, not as described below.
c    a) Currently, this keyboard outputs a fudge for saltillo in Unicode (U+02C8) as well as in ANSI ('), since 
c       the proposal to have this character added to Unicode has not yet been accepted.  There is a PUA character for it 
c       in Doulos SIL and Charis SIL (U+F21D), but not other fonts, and even in the SIL fonts may give problems with behavior.  
c       Because this character is so widely-used in the Mexico branch of SIL, the branch has decided to use 
c       U+02C8 MODIFIER LETTER VERTICAL LINE for now rather than the SIL-PUA character, except 
c       when high-quality output is required.  Similarly, for ANSI applications, this keyboard is set up to encode saltillo 
c       as a straight apostrophe.  If you want to use a different character for saltillo, edit the stores named 
c       "saltillo", which are defined below at "PATCH AREA acute and saltillo".  Do not just search the code 
c       for U+02C8 and replace it with something else; other instances of U+02C8 are for representing 
c       stress, and should remain as U+02C8, regardless of how you want to represent saltillo.
c    b) You may prefer to use apostrophe to type acute accent rather than CTRL+apostrophe.  Some people may also 
c       want to use apostrophe to type saltillo, and there is an easy way 
c       to enable this below (search for "PATCH AREA saltillo").  However, these two uses can conflict
c       following a vowel.  For example, if users type the sequence a'' they should end up with "a" plus
c       saltillo, not "a" plus apostrophe.  Otherwise, they will likely be introducing a mixture
c       of saltillos and apostrophes in their data rather than consistently entering saltillos.
c       The way to avoid this problem is explained below; seach for "nrmlRsltAcute".

c 4) If you want to disable trigger keys that you don't need, redefine them, or define new
c    ones; see the detailed instructions at "PATCH AREA trigger keys".

c 5) To add a new character or combination of base character and diacritic, many times all you need to do 
c    is add it to the appropriate pair of stores (e.g. store(baseAcute) and store(Acute)).  Other times,
c    you may need to add other lines of code or even a new trigger key.  If so, study existing code carefully;
c    I suggest you do most of your modifications by copying and pasting existing code, then adjusting the details.

c 6) To change an existing character, be sure to search for its codepoint throughout the source code, because some characters can be
c    generated in more than one way and thus appear in more than one place in the source code.

c 7) There *may* be SIL PUA characters that are generated by the Unicode sections this keyboard.  Once we get
c    official Unicode codepoints for them, they should be changed (and, of course, any data previously typed 
c    with this keyboard will need to be converted).  You can find them, if they are present, by searching for instances of 
c    "U+E" and "U+F".





c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c PATCH AREA trigger keys

c These stores are used to simplify modifications of the keyboard for 
c people who prefer different keystroke combinations. It also provides 
c an overview of the most important trigger keys and what they are used for. 
c (There are a few additional trigger keys scattered through the code which are only used in a small number of combinations.)

c I. Each of the stores for trigger keys should contain only a single keystroke.  If you want to use the same key for two 
c    different purposes, test carefully to make sure there are no conflicts.  Especially for diacritic trigger keys, avoid this, 
c    even if trigger key A is only used with keyDiac and trigger key B may be used without it, because there are times when
c    trigger key B may also need to be typed with keyDiac (e.g., to place the diacritic on no-break space).

c II. To disable a trigger key, thus eliminating a whole class of changes, don't just leave the 
c   store for the trigger key empty (the keyboard may not compile), and definitely don't comment it out.  
c   The best thing to do is to specify some key that is extremely unlikely to be typed, such as [K_?FF], 
c   which represents an unknown keycode that probably never occurs on any hardware keyboard nor is ever used 
c   by any application.  For example, the following line will disable all macron vowels:
c       store(keyMacron)   [K_?FF]

c III. To add a new trigger key for a previously unsupported diacritic, you also need to make changes
c   in several other places.  You should check the following:
c     PATCH AREA all diacritics     (to enable keyDiac sequences and configure proper behavior after space)
c     PATCH AREA baseCom            
c     PATCH AREA individual diacritics
c   Study the code carefully in those places to see what is needed, as well as the rest of these initial instructional comments.  
c   I suggest that as you add lines of code for new diacritics, you maintain the convention of keeping diacritics in order 
c   within each section according to their Unicode codepoint.

c IV. For new trigger keys that don't produce diacritics but rather change one character into another, there are similar  
c   adjustments to make in the code but fewer than for diacritics; search for the store "IPA" or "baseIPA" to see how this is done.

c V. There are different categories of trigger keys, which vary on two independent dimensions.  If you change a trigger key
c   in either of these ways, you will need to adjust code at several places.
c   A. Some trigger keys are "visible", that is, in their normal use, they produce a printable character.  Others are
c      "invisible", in other words, combinations of CTRL and/or ALT.  
c   B. For diacritics, some trigger keys only have meaning as trigger keys following keyDiac; when used alone they have no 
c      special significance.  These tend to be for rarer diacritics.  (Many of these also have visible trigger keys, but possibly not all.)  
c      These should be identified with comments in the store definitions below.  
c      Other diacritic trigger keys are usually used by themselves, although they may be optionally
c      preceded by keyDiac (and if so, will force a diacritic into a context that might not otherwise accept it).

c V. If you want to use visible trigger keys for diacritics that will (at least some of the time)
c   be represented with combining marks, and if those trigger keys will typically be used 
c   without keyDiac, then you should set up a baseCom_(diacritic)_ store for those
c   base characters that can accept the diacritic as a combining mark.
c   The reason is that we only want the trigger key to be translated to a combining mark following certain characters;
c   in other places, the key (when used without keyDiac) should introduce a composite character or just be inserted without translation.
c   Then, you should use the baseCom_(diacritic)_ store in the "PATCH AREA individual diacritics".  Depending on the diacritic, 
c   you may need to do this in the ANSI group as well as in the Unicode group.
c   See further discussion and explanation below under "PATCH AREA baseCom" and "PATCH AREA individual diacritics".   

c VI. If you want to use invisible trigger keys, there are several things to remember:
c
c a. Invisible trigger keys only work when they are typed after the character they modify.  (Either
c    that, or you you'd have to modify the code more extensively so an invisible trigger key typed before was treated as a deadkey,
c    because you wouldn't want the invisible trigger key to sneak through to the application and cause havoc before the user has 
c    a chance to type the next key.)
c
c b. Don't use invisible keys that are likely to have special meaning in applications; you'll make those functions inaccessible.  
c    Thus, it is best to avoid function keys or any combination with CTRL or ALT that involves a letter.  
c    ALT+? should not be used because this calls up the help menu on some non-English versions of applications.
c    Word uses a few important CTRL and ALT combinations with SPACE, ENTER, HYPHEN, and UNDERLINE, so also avoid these.
c
c c. Code the trigger key as a virtual character key whenever one is available, not a virtual key, since this is a 
c    mnemonic keyboard (new feature in version 6.0 of Keyman).  For example, use [CTRL "\"] rather than [CTRL K_BKSLASH].
c    If you use a virtual key, TIKE will warn you about this when you compile the keyboard.
c    I anticipate that the result will not work as expected if the underlying Windows keyboard is anything 
c    other than the default U.S. keyboard, but I haven't tested it yet.  Virtual keys, however, can be used if there is no 
c    corresponding virtual character key. Thus, for example, [CTRL ALT K_LEFT] could be used as a trigger key.
c
c d. Test the CTRL or ALT combination, to make sure the trigger key is never sent through to the 
c    application.  If it does get through, it may produce strange results such as 
c    moving the cursor, deleting text, activating a menu, or blocking subsequent key translations.  
c    To avoid these problems, at various places, the code for invisible trigger keys is different 
c    from the code for visible trigger keys.  See the following PATCH AREAs for more details:
c      PATCH AREA all diacritics
c      PATCH AREA baseCom
c      PATCH AREA individual diacritics
c
c    One quick way to tell if you are going to have problems is to test the CTRL or ALT trigger key in TIKE.  
c    If, when you press the trigger key several times, the base character simply toggles back and forth
c    between the ordinary and special characters or generates a beep, then there should be no problem.  
c    The trigger key is not being sent to the output. If, after 1 or 2 repretitions, further presses of the trigger key cause no 
c    further changes or beeps, then this means the trigger key is being put in the context (and thus passed through to 
c    the output) and this will likely cause problems in some applications.  If so, investigate the PATCH AREAs
c    listed above.

c VII. With regard to keyDiac sequences for typing diacritics:
c    A. Having keyDiac available in the keyboard makes it much more feasible to use visible characters as trigger keys.
c       Most of the diacritics which have visible trigger keys require the use of keyDiac, and most of the diacritics
c       which require keyDiac have visible trigger keys.
c    B. If a trigger key is used with keyDiac, then it should have no distinct use as a trigger when typed by itself.  It
c       may generate the same diacritic by itself, or (as a visible key) generate its normal character, but not 
c       anything else.  This is necessary in order to preserve a consistent pattern of usage for keyDiac. If the trigger
c       key has its special meaning only when used with keyDiac, this should be noted in a comment by its definition.
c    C. Do not include the keyDiac key in any other store, even for those trigger keys that always require you to type 
c       it. This is a special case of the requirement that each trigger key store be a single character. 
c       The sequences of keyDiac plus diacritic trigger key are all handled elsewhere in the code.  
c    D. If you want to change a diacritic from always using keyDiac to optionally 
c       using it or vice versa, you will need to add, subtract, or modify lines of code at other places, such as:
c           in this section, add or delete a comment that indicates that the trigger key is only used with keyDiac
c           PATCH AREA individual diacritics: add or delete lines that use keyDiac in combination with the trigger key
c           the corresponding portions of the ANSI group, if relevant
c       How to do this is not well described in the comments, because I don't anticipate that it will be necessary
c       very often.  If necessary, study the examples in those places carefully to see how this is handled.

c A few trigger keys are used before a single character
c (These must be visible trigger keys, not invisible.)
store(keyDiac)          "%"         c following key is a diacritic 
                                    c Required preceding trigger characters for rare diacritics, optional otherwise.
                                    c When optional, its use 
                                    c a) always invokes a diacritic, even on base characters that
                                    c    don't normally take that diacritic, see "PATCH AREA baseCom" below, 
                                    c b) is normally required for typing diacritics in isolation, i.e. on a no-break space
                                    c c) allows stacking of two instances of the same diacritic, for what it's worth.

c Most trigger keys are typed after one or more base characters.
store(keyRaised)        [CTRL "^"]              c raised (superscript) characters
store(keyLowered)       [CTRL SHIFT "^"]        c lowered (subscript) characters
store(keyLarger)        [CTRL ALT "^"]          c make character larger without shifting vertically
store(keySmaller)       [CTRL ALT SHIFT "^"]    c make character smaller without shifting vertically, e.g. small caps
store(keyRev)           [CTRL "#"]              c reversed characters (flipped horizontally)
store(keyTurn)          [CTRL SHIFT "#"]        c turned (Rotated upside-down) and inverted (flipped vertically) characters
store(keyPhGrk)         [CTRL "/"]              c phonetic characters based on Greek letters
store(keyIPA)           [CTRL "&"]              c miscellaneous IPA and other phonetic symbols
store(keyPalMisc)       [CTRL SHIFT "/"]        c letters with curls for indicating palatal-ish sounds (cf. palatal hook diacritic)
store(keyClick)         [CTRL "!"]              c clicks (i.e., as in Xhosa and other south African languages, not mouse clicks) 
store(keyCurr)          "$"                     c currency symbols
store(keyMath)          "#"                     c mathematical symbols
store(keyLig)           "&"                     c ligatures and other combinations of 2 or more characters, 
                                                c where the joining doesn't happen automatically
store(keyLeft)          [CTRL ALT K_LEFT]           c left (W) directional modifier
store(keyDL)            [CTRL ALT SHIFT K_LEFT]     c down left (SW) directional modifier
store(keyDown)          [CTRL ALT K_DOWN]           c down (S) directional modifier
store(keyDR)            [CTRL ALT SHIFT K_DOWN]     c down right (SE) directional modifier
store(keyRight)         [CTRL ALT K_RIGHT]          c right (E) directional modifier
store(keyUR)            [CTRL ALT SHIFT K_RIGHT]    c up right (NE) directional modifier
store(keyUp)            [CTRL ALT K_UP]             c up (N) directional modifier
store(keyUL)            [CTRL ALT SHIFT K_UP]       c up left (NW) directional modifier

c Diacritic trigger keys are always typed after the base character.
c
c The Unicode values given below are for the corresponding combining marks; many of these triggers also are used to generate
c composite characters (and this keyboard usually generates composites whenever Unicode has them).
c 
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
c * * It's especially important to read the instructions above before making modifications here!  * *
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
c 
store(keyRhoticHook)    "r"                     c U+02DE MODIFIER LETTER RHOTIC HOOK
c                                                 (Has this meaning only when following keyDiac.)
store(keyGrave)         [CTRL "`"]              c U+0300 COMBINING GRAVE ACCENT
store(keyAcute)         [CTRL "'"]              c U+0301 COMBINING ACUTE ACCENT
store(keyCirc)          [CTRL "}"]              c U+0302 COMBINING CIRCUMFLEX ACCENT 
store(keyTilde)         "`"                     c U+0303 COMBINING TILDE
store(keyMacron)        [CTRL "|"]              c U+0304 COMBINING MACRON
c store(keyOverline)                            c U+0305 COMBINING OVERLINE; probably not needed for linguistics
store(keyBreve)         [CTRL "("]              c U+0306 COMBINING BREVE
store(keyDot)           [CTRL "."]              c U+0307 COMBINING DOT ABOVE (old IPA palatlization)
store(keyDiaer)         [CTRL ":"]              c U+0308 COMBINING DIAERESIS
c store(keyHookA)                               c U+0309 COMBINING HOOK ABOVE; only needed for Vietnamese 
store(keyRing)          [CTRL "*"]              c U+030A COMBINING RING ABOVE
c store(keyDblAcute)                            c U+030B COMBINING DOUBLE ACUTE ACCENT, use two instances of keyAcute
store(keyCaron)         [CTRL "{"]              c U+030C COMBINING CARON
store(keyVertLn)        "'"                     c U+030D COMBINING VERTICAL LINE ABOVE
c                                                 (Has this meaning only when following keyDiac.)
store(keyDblVert)       [CTRL "="]              c U+030E COMBINING DOUBLE VERTICAL LINE ABOVE
c                                                 (Has this meaning only when following keyDiac.)
c store(keyDblGrave)                            c U+030F COMBINING DOUBLE GRAVE ACCENT, use two instances of keyGrave
store(keyInvBreve)      [CTRL ")"]              c U+0311 COMBINING INVERTED BREVE
store(keyCedillaA)      [CTRL ","]              c U+0312 COMBINING TURNED COMMA ABOVE (= CEDILLA ABOVE)
store(keyCommaA)        "c"                     c U+0313 COMBINING COMMA ABOVE (Greek smooth breathing mark)
c                                                 (Has this meaning only when following keyDiac.)
store(keyGraveB)        [CTRL SHIFT "`" ]       c U+0316 COMBINING GRAVE ACCENT BELOW
store(keyAcuteB)        [CTRL SHIFT "'"]        c U+0317 COMBINING ACUTE ACCENT BELOW
                                                c U+0318 COMBINING LEFT TACK BELOW: see directional modifiers (IPA Advanced tongue root)
                                                c U+0319 COMBINING RIGHT TACK BELOW: see directional modifiers (IPA Retracted tongue root)
store(keyLeftAngle)     [CTRL "#"]              c U+031A COMBINING LEFT ANGLE ABOVE (IPA unreleased stop)       
c                                                 (Has this meaning only when following keyDiac.)
                                                c U+031C COMBINING LEFT HALF RING BELOW: see directional modifiers (IPA less rounded)
                                                c U+031D COMBINING UP TACK BELOW: see directional modifiers (IPA vowel raising)
                                                c U+031E COMBINING DOWN TACK BELOW: see directional modifiers (IPA vowel lowering)
store(keyPlusB)         "+"                     c U+031F COMBINING PLUS SIGN BELOW
c                                                 (Has this meaning only when following keyDiac.)
store(keyMinusB)        "-"                     c U+0320 COMBINING MINUS SIGN BELOW
c                                                 (Has this meaning only when following keyDiac.)
store(keyPalHookB)      ","                     c U+0321 COMBINING PALATALIZED HOOK BELOW (IPA palatalization) 
c                                                 (Has this meaning only when following keyDiac.)
c                                                 (Cf. also the palatal modification for curls above.)
store(keyRetroHookB)    ";"                     c U+0322 COMBINING RETROFLEX HOOK BELOW (IPA retroflexion)
c                                                 (Has this meaning only when following keyDiac.)
store(keyDotB)          [CTRL SHIFT "."]        c U+0323 COMBINING DOT BELOW
store(keyDiaerB)        [CTRL SHIFT ':']        c U+0324 COMBINING DIAERESIS BELOW
store(keyRingB)         [CTRL SHIFT "*"]        c U+0325 COMBINING RING BELOW
store(keyCommaB)        "C"                     c U+0326 COMBINING COMMA BELOW
c                                                 (Has this meaning only when following keyDiac.)
store(keyCedilla)       [CTRL SHIFT ","]        c U+0327 COMBINING CEDILLA (below)
store(keyOgonek)        "n"                     c U+0328 COMBINING OGONEK (=polish/nasal hook, Americanist nasalization)
c                                                 (Has this meaning only when following keyDiac.)
store(keyVertLnB)       [SHIFT "'"]             c U+0329 COMBINING VERTICAL LINE BELOW (IPA syllabic)
c                                                 (Has this meaning only when following keyDiac.)
store(keyBridgeB)       [CTRL ALT SHIFT "]"]    c U+032A COMBINING BRIDGE BELOW (IPA dental)
store(keyInvDblArchB)   "{"                     c U+032B COMBINING INVERTED DOUBLE ARCH BELOW (IPA labialization)
c                                                 (Has this meaning only when following keyDiac.)
store(keyCaronB)        [CTRL SHIFT "{"]        c U+032C COMBINING CARON BELOW
store(keyCircB)         [CTRL SHIFT "}"]        c U+032D COMBINING CIRCUMFLEX ACCENT BELOW (Americanist fronted articulation)
store(keyBreveB)        [CTRL SHIFT "("]        c U+032E COMBINING BREVE BELOW 
store(keyInvBreveB)     [CTRL SHIFT ")"]        c U+032F COMBINING INVERTED BREVE BELOW
store(keyTildeB)        "~"                     c U+0330 COMBINING TILDE BELOW (IPA creaky voice)
store(keyMacronB)       [CTRL SHIFT "|"]        c U+0331 COMBINING MACRON BELOW = underline
store(keyTildeO)        [CTRL ALT "~"]          c U+0334 COMBINING TILDE OVERLAY
store(keyStroke)        [CTRL ALT "|"]          c U+0335 COMBINING SHORT STROKE OVERLAY; U+0336 COMBINING LONG STROKE OVERLAY 
store(keySlash)         [CTRL ALT "/"]          c U+0337 COMBINING SHORT SOLIDUS OVERLAY; U+0338 COMBINING LONG SOLIDUS OVERLAY
                                                c U+0339 COMBINING RIGHT HALF RING BELOW: see directional modifiers (IPA more rounded)
store(keyInvBridgeB)    [CTRL ALT SHIFT "["]    c U+033A COMBINING INVERTED BRIDGE BELOW (IPA apical)
                                                c U+033B COMBINING SQUARE BELOW, use sequence of inverted bridge below and bridge below
store(keySeagullB)      "}"                     c U+033C COMBINING SEAGULL BELOW
c                                                 (Has this meaning only when following keyDiac.)
store(keyX)             "x"                     c U+033D COMBINING X ABOVE
c                                                 (Has this meaning only when following keyDiac.)
store(keyBridge)        [CTRL ALT "]"]          c U+0346 COMBINING BRIDGE ABOVE (IPA dentolabial)
store(keyDblVertB)      [CTRL SHIFT "="]        c U+0348 COMBINING DOUBLE VERTICAL LINE BELOW (IPA strong articulation, fortis)
c                                                 (Has this meaning only when following keyDiac.)
store(keyLeftAngleB)    [CTRL SHIFT "#"]        c U+0349 COMBINING LEFT ANGLE BELOW (IPA weak articulation)
c                                                 (Has this meaning only when following keyDiac.)
store(keyXB)            "X"                     c U+0353 COMBINING X BELOW
c                                                 (Has this meaning only when following keyDiac.)
                                                c U+035C COMBINING DOUBLE BREVE BELOW, achieved by using keyLower on U+035D COMBINING DOUBLE BREVE
store(keyDblBreve)      "("                     c U+035D COMBINING DOUBLE BREVE
c                                                 (Has this meaning only when following keyDiac.)
store(keyDblMacron)     "|"                     c U+035E COMBINING DOUBLE MACRON
c                                                 (Has this meaning only when following keyDiac.)
                                                c U+035F COMBINING DOUBLE MACRON BELOW, achieved by using keyLower on U+035E COMBINING DOUBLE MACRON
store(keyDblInvBreve)   ")"                     c U+0361 COMBINING DOUBLE INVERTED BREVE
c                                                 (Has this meaning only when following keyDiac.)
store(keySnakeB)        "s"                     c U+1DC2 COMBINING SNAKE BELOW
c                                                 (Has this meaning only when following keyDiac.)


c ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
             
c Stores that summarize all the diacritics and their trigger keys
c PATCH AREA all diacritics
c (This section is not relevant to the ANSI keyboard for now, but may be needed to implement diacritics in isolation.)  
c
c There are two purposes for the stores in this section:
c
c 1) Every trigger key used for a diacritic needs to be included in the DiacTrig store, and the corresponding diacritic itself 
c   (usually a combining mark) must be included in the Diac store.  This (in combination with later code) is what causes 
c   the sequence of keyDiac plus diacritic trigger key to be transformed to the combining mark.
c 
c 2) Combining marks should be blocked from being introduced in certain contexts, 
c   such as after space and newline.  To do this, diacritics with visible trigger keys need to be distinguished here from 
c   those that have invisible trigger keys.  (Code elsewhere discards the invisible ones in these contexts and 
c   makes sure the visible ones only generate their ordinary character rather than a combining mark.)
c
c So, the following store definitions are in two major clumps, depending on whether they have visible trigger keys,
c then they are joined together at the end.
c
c Diacritics with invisible trigger keys:
    store(IT0)     outs(keyGrave) outs(keyAcute) outs(keyCirc) outs(keyMacron) outs(keyBreve) outs(keyDot)
    store(D4IT0)   U+0300         U+0301         U+0302        U+0304          U+0306         U+0307      
    store(IT1)     outs(keyDiaer) outs(keyRing) outs(keyCaron) outs(keyDblVert) 
    store(D4IT1)   U+0308         U+030A        U+030C         U+030E           
    store(IT2)     outs(keyInvBreve) outs(keyCedillaA) outs(keyGraveB) outs(keyAcuteB) outs(keyLeftAngle) 
    store(D4IT2)   U+0311            U+0312            U+0316          U+0317          U+031A             
    store(IT3)     outs(keyDotB) outs(keyDiaerB) outs(keyRingB) outs(keyCedilla) 
    store(D4IT3)   U+0323        U+0324          U+0325         U+0327           
    store(IT4)     outs(keyBridgeB) outs(keyCaronB) outs(keyCircB) outs(keyBreveB) outs(keyInvBreveB)
    store(D4IT4)   U+032A           U+032C          U+032D         U+032E          U+032F
    store(IT5)     outs(keyMacronB) outs(keyTildeO) outs(keyStroke) outs(keySlash) outs(keyInvBridgeB) 
    store(D4IT5)   U+0331           U+0334          U+0336          U+0337         U+033A              
    store(IT6)     outs(keyBridge) outs(keyDblVertB) outs(keyLeftAngleB) 
    store(D4IT6)   U+0346          U+0348            U+0349              
    store(InvisibleTrigger) outs(IT0)    outs(IT1)    outs(IT2)    outs(IT3)    outs(IT4)    outs(IT5)    outs(IT6)    
    store(Diac4InvTrig)     outs(D4IT0)  outs(D4IT1)  outs(D4IT2)  outs(D4IT3)  outs(D4IT4)  outs(D4IT5)  outs(D4IT6)    
c
c Diacritics with visible trigger keys:
    store(VT1)    outs(keyRhoticHook) outs(keyTilde) outs(keyVertLn) outs(keyCommaA) outs(keyPlusB) outs(keyMinusB) 
    store(D4VT1)  U+02DE              U+0303         U+030D          U+0313          U+031F         U+0320          
    store(VT2)    outs(keyPalHookB) outs(keyRetroHookB) outs(keyCommaB) outs(keyOgonek) outs(keyVertLnB) outs(keyInvDblArchB) 
    store(D4VT2)  U+0321            U+0322              U+0326          U+0328          U+0329           U+032B               
    store(VT3)    outs(keyTildeB) outs(keySeagullB) outs(keyX) 
    store(D4VT3)  U+0330          U+033C            U+033D     
    store(VT5)    outs(keyXB) 
    store(D4VT5)  U+0353      
    store(VT6)    outs(keyDblBreve) outs(keyDblMacron) outs(keyDblInvBreve) outs(keySnakeB)  
    store(D4VT6)  U+035D            U+035E             U+0361               U+1DC2 
    store(VisibleTrigger)   outs(VT1)   outs(VT2)   outs(VT3)   outs(VT5)   outs(VT6)   
    store(Diac4VisTrig)     outs(D4VT1) outs(D4VT2) outs(D4VT3) outs(D4VT5) outs(D4VT6) 
c
c currently not included in either store, because they aren't defined (there may also be others):
c   outs(keyDblAcute) outs(keyDblGrave)
c   U+030B            U+030F
c
c Now put everything together for use with keyDiac
store(DiacTrig) outs(VisibleTrigger) outs(InvisibleTrigger)
store(CombMark) outs(Diac4VisTrig)   outs(Diac4InvTrig)     

c Because of the above code and the way the keyDiac key is handled in the Unicode group, 
c almost all keyDiac sequences generate combining marks, even if typing the trigger key without keyDiac
c produces a composite.  To change this behavior generally, we would have to move all the code for assembling composites 
c to a separate group, and its not clear that that's a good idea (see discussion in "BU Enhancements.doc").  In the meantime, if you 
c need a keyDiac sequence to generate a composite character, then see "PATCH AREA individual diacritics"; there needs to be 
c a separate line of code added to that section for each combination of keyDiac plus a diacritic trigger key that should generate composites.  
c 
c And, of course, you will also need to make sure there are base_(diacritic)_ and _(diacritic)_ stores at "PATCH AREA composite".

c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c Miscellaneous codes referring to individual characters or small groups of them

c Several of these need to be defined before the general stores, which make reference to them, 
c but after the trigger keys for diacritics are defined.
                    
c Special handling for dotless exclamation ("saltillo") and acute accent
c PATCH AREA acute and saltillo
c See also discussion above in the warnings about how to modify the keyboard, and code below for 2nd keypress on acute accent.
c Codepoints to use to represent dotless exclamation (enlarged straight apostrophe, "saltillo")
store(saltillo)    U+F21D   c Unicode: Use U+F21D from the private use area in SIL Doulos and SIL Charis
c store(saltillo)    U+02C8   c Unicode: Use U+02C8 MODIFIER LETTER VERTICAL LINE as a fudge until dotless exclamation gets added
store(saltillo-A)  "'"      c ANSI: Use straight apostrophe; alternately could use the SIL-Mexico "standard" custom codepoint xDF (normally 'ß')
    
c What normally results from typing the trigger key for acute accent (i.e. when it doesn't get translated to acute).
c   Because some users may want to use ordinary apostrophe as a trigger key for both acute and for saltillo,
c   we need a store to indicate what keyAcute produces when it is used by itself (i.e. when it is translated to saltillo).
c   This is because typing keyAcute a 2nd time should produce the vowel plus what that key normally produces by itself, not following a vowel.
c 
c nrmlRsltAcute should be:
c   if the same visible character (most likely apostrophe) is used for both acute accent and saltillo, use outs(saltillo)
c   otherwise use outs(keyAcute)  
store(nrmlRsltAcute) outs(keyAcute)
c If keyAcute is an invisible trigger, then this store is never used.
c But, leave the line here; it is harmless and makes modifications to the keyboard easier.

c Others
store(nbsp) U+00A0          c non-breaking space
store(FracSlash) '/'        c character to be used for the slash in fractions, typically either '/' or U+2044 FRACTION SLASH
                            c At least in Doulos SIL, the ordinary slash looks better.

c ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
             
c Stores for general special characters
c PATCH AREA general

c clicks (i.e., as in Xhosa, not as in mouse) (Unicode only)
store(baseClick)    'p'    's'    't'    'l'    'c'    'r'    
store(Click)        U+0298 U+01C0 U+01C2 U+01C1 U+0297 U+01C3

c The Digit stores are used not only for making raised and lowered characters, but also in forming fractions.                                                                                                            
store(baseDigit)    '0'    '1'    '2'    '3'    '4'    '5'    '6'    '7'    '8'    '9'    
store(RsdDigit)     U+2070 U+00B9 U+00B2 U+00B3 U+2074 U+2075 U+2076 U+2077 U+2078 U+2079 
store(LowDigit)     U+2080 U+2081 U+2082 U+2083 U+2084 U+2085 U+2086 U+2087 U+2088 U+2089 

c raised characters
store(baseRaised-A)  '123.ao'
store(Raised-A)      '¹²³·ªº'   
c ANSI stores can't be combined with Unicode, because of the different handling of raised a and o and of fractions
c                                 turnda alphas        AE     trndae        smcpB-        beta          c-curl               eth           rev-E         schwa  open e's                                  gamma  
store(baseRaised1)  'A'    'a'    U+0250 U+0251 U+0252 U+00C6 U+1D02 'B'    U+1D03 'b'    U+03B2 'c'    U+0255 'D'    'd'    U+00F0 'E'    U+018E 'e'    U+0259 U+025B U+1D08 U+025C 'f'    'G'    'g'    U+0263 
store(Raised1)      U+1D2C U+1D43 U+1D44 U+1D45 U+1D9B U+1D2D U+1D46 U+1D2E U+1D2F U+1D47 U+1D5D U+1D9C U+1D9D U+1D30 U+1D48 U+1D9E U+1D31 U+1D32 U+1D49 U+1D4A U+1D4B U+1D4C U+1D9F U+1DA0 U+1D33 U+1D4D U+02E0 
c                                 trndh  hooktp        smcapI I-     smcapI-       trndi  i-     iota                 jcurl  dotlj-        
store(baseRaised3)  'H'    'h'    U+0265 U+0266 'I'    U+026A U+0197 U+1D7B 'i'    U+1D09 U+0268 U+0269 'J'    'j'    U+029D U+025F 'K'    'k'    
store(Raised3)      U+1D34 U+02B0 U+1DA3 U+02B1 U+1D35 U+1DA6 U+1DA7 U+1DA7 U+2071 U+1D4E U+1DA4 U+1DA5 U+1D36 U+02B2 U+1DA8 U+1DA1 U+1D37 U+1D4F 
c                          smcapL        lpal   lretro               trndm  mhook  mtrnll        smcapN revN          eng    nlfthk nretro
store(baseRaised4)  'L'    U+029F 'l'    U+1D85 U+026D 'M'    'm'    U+026F U+0271 U+0270 'N'    U+0274 U+1D0E 'n'    U+014B U+0272 U+0273
store(Raised4)      U+1D38 U+1DAB U+02E1 U+1DAA U+1DA9 U+1D39 U+1D50 U+1D5A U+1DAC U+1DAD U+1D3A U+1DB0 U+1D3B U+207F U+1D51 U+1DAE U+1DAF
c                                 openo  o-     OU                   phi           invR          trndr  trndrret      sretr  esh    
store(baseRaised5)  'O'    'o'    U+0254 U+0275 U+0222 'P'    'p'    U+0278 'R'    U+0281 'r'    U+0279 U+027B 's'    U+0282 U+0283  
store(Raised5)      U+1D3C U+1D52 U+1D53 U+1DB1 U+1D3D U+1D3E U+1D56 U+1DB2 U+1D3F U+02B6 U+02B3 U+02B4 U+02B5 U+02E2 U+1DB3 U+1DB4  
c                                 t-pal  theta         smcapU        u-     upsilon       vhook  trndv                       chi                         zcurl  zretro ezh
store(baseRaised6)  'T'    't'    U+01AB U+03B8 'U'    U+1D1C 'u'    U+0289 U+028A 'v'    U+028B U+028C 'W'    'w'    'x'    U+03C7 'y'    'z'    U+0291 U+0290 U+0292
store(Raised6)      U+1D40 U+1D57 U+1DB5 U+1DBF U+1D41 U+1DB8 U+1D58 U+1DB6 U+1DB7 U+1D5B U+1DB9 U+1DBA U+1D42 U+02B7 U+02E3 U+1D61 U+02B8 U+1DBB U+1DBD U+1DBC U+1DBE
c                                                                             glottals      phryng
store(baseRaisedSym)  '+'    '-'    '='    '('    ')'    '.'    '|'    ':'    U+0294 '?'    U+0295
store(RaisedSym)      U+207A U+207B U+207C U+207D U+207E U+00B7 U+02C8 U+02F8 U+02C0 U+02C0 U+02E4
c in the above, list 0294 before '?' so that 02C0 gets transformed back to 0294 not '?' if it is ever reversed by a 2nd keypress.
store(baseRaised)   outs(baseRaised1) outs(baseRaised3) outs(baseRaised4) outs(baseRaised5) outs(baseRaised6) outs(baseDigit) outs(baseRaisedSym)
store(Raised)       outs(Raised1)     outs(Raised3)     outs(Raised4)     outs(Raised5)     outs(Raised6)     outs(RsdDigit)  outs(RaisedSym)

c Characters which in Unicode can take underline (using combining macron below) 
c   and then be raised to a composite underlined superscript
c In the ANSI keyboard, these stores are not used; the underlining is added at the same time 
c   as raising the base letter with keyRaised.
store(baseRaisedUL) 'ao'
store(RaisedUL)     'ªº'
                                                   
c there are no ANSI characters that are lowered (low 9 quotes are generated with DirMod)
c                          beta          gamma  schwa                phi                                chi
store(baseLowered1) 'a'    U+03B2 'e'    U+0263 U+0259 'i'    'o'    U+0278 'r'    'u'    'v'    'x'    U+03C7
store(Lowered1)     U+2090 U+1D66 U+2091 U+1D67 U+2094 U+1D62 U+2092 U+1D69 U+1D63 U+1D64 U+1D65 U+2093 U+1D6A
c                                                                dblBreve dblMacr
store(baseLoweredPunc) '+'    '-'    '='    '('    ')'    '|'    U+035D   U+035E 
store(LoweredPunc)     U+208A U+208B U+208C U+208D U+208E U+02CC U+035C   U+035F
c
store(baseLowered)  outs(baseLowered1) outs(baseLoweredPunc) outs(baseDigit)
store(Lowered)      outs(Lowered1)     outs(LoweredPunc)     outs(LowDigit)   

c letters made larger (Unicode only)
c Mostly, this turns phonetic symbols into their corresponding upper-case version, or something close to it
c                   ae     schwa  rev-e  open-e gamma  iota   trndm  eng    nlfthk openo  oe
store(baseLarger)   U+00E6 U+0259 U+0258 U+025B U+0263 U+0269 U+026F U+014B U+0272 U+0254 U+0153
store(Larger)       U+00C6 U+018F U+018E U+0190 U+0194 U+0196 U+019C U+014A U+019D U+0186 U+0152

c letters made smaller (Unicode only)
c                                 smcapG               I^     Ibar          L^     Lslash        N^                   U^            OE     OU     gamma
store(baseSmaller)  'B'    'G'    U+0193 'H'    'I'    U+1D35 U+0197 'L'    U+1D38 U+0141 'N'    U+1D3A 'R'    'U'    U+1D41 'Y'    U+0152 U+0222 U+0263
store(Smaller)      U+0299 U+0262 U+029B U+029C U+026A U+1DA6 U+1D7B U+029F U+1DAB U+1D0C U+0274 U+1DB0 U+0280 U+1D1C U+1DB8 U+028F U+0276 U+1D15 U+0264
c There are lots more in 1D00 Phonetic extensions

c reversed symbols (flipped horizontally) (Unicode only)
c                          ^E            open e's             clope         ^N     smcapR        invR   fshhkr Ezh    ezh    glottals                    comma_above
store(baseRev)      'E'    U+1D31 'e'    U+025B U+1D4B U+1D93 U+029A 'N'    U+1D3A U+0280 'R'    U+0281 U+027E U+01B7 U+0292 U+0294 '?'    U+02A1 U+02C0 U+0313
store(Rev)          U+018E U+1D32 U+0258 U+025C U+1D9F U+1D94 U+025E U+1D0E U+1D3B U+1D19 U+1D19 U+1D1A U+027F U+01B8 U+01B9 U+0295 U+0295 U+02A2 U+02E4 U+0314
c list 0294 before '?', so that reversing 0295 results in 0294 not '?'

c turned symbols (i.e., rotated upside-down); some are actually inverted (flipped vertically)
store(baseTurn-A) '?!'          
store(Turn-A)     '¿¡'  
c there is no way to generate U+01DD LATIN SMALL LETTER TURNED E (used in pan-Nigerian scripts) because the appropriate 
c 'e' with keyTurn is used to generate U+0259 LATIN SMALL LETTER SCHWA instead.
c                          ^a     alpha  ^alpha ae                                ^e      elower e-retr open e's              
store(bT1)          'a'    U+1D43 U+0251 U+1D45 U+00E6 'C'    'c'    'E'    'e'    U+1D49 U+2091 U+1D92 U+025B U+1D4B 'g'     
store(t1)           U+0250 U+1D44 U+0252 U+1D9B U+1D02 U+0186 U+0254 U+018F U+0259 U+1D4A U+2094 U+1D95 U+1D08 U+1D4C U+1D77  
c                          ^h            ^i                   ^m            smcpR        smcprvR ^R            retror ^r   
store(bT2)          'h'    U+02B0 'i'    U+2071 'M'    'm'    U+1D50 't'    U+0280 'R'    U+1D19 U+1D3F 'r'    U+027D U+02B3 
store(t2)           U+0265 U+1DA3 U+1D09 U+1D4E U+019C U+026F U+1D5A U+0287 U+0281 U+0281 U+1D1A U+02B6 U+0279 U+027B U+02B4 
c                                                                                         comma 
c                          v^                   +-     glttl                       stress setOps above
store(bT3)          'v'    U+1D5B 'w'    'y'    U+00B1 U+0294 U+0295 U+02A1 U+02A2 U+02C8 U+222A U+0313 
store(t3)           u+028C U+1DBA U+028D U+028E U+2213 U+0296 U+0296 U+01BE U+01BE U+02CC U+2229 U+0312 
store(baseTurn)     outs(baseTurn-A) outs(bT1) outs(bT2) outs(bT3)
store(Turn)         outs(Turn-A)     outs(t1)  outs(t2)  outs(t3)

c Phonetic symbols based on Greek
store(basePhGrk-A)  'm'
store(PhGrk-A)      'µ'
c                          ^a     trnd-a ^trnd-a       beta                 opene  ^e     schwa  ^schwa rvsd-e rvop-e  e-retro
store(basePG1)      'a'    U+1D43 U+0250 U+1D44 'b'    U+1D47 'E'    'e'    U+025B U+1D49 U+0259 U+1D4A U+0258 U+025C  U+1D92 
store(PG1)          U+0251 U+1D45 U+0252 U+1D9B U+03B2 U+1D5D U+0190 U+025B U+029A U+1D4B U+1D08 U+1D4C U+025C U+025E  U+1D93 
c                                 g^                   i^                   p^                   u^     u-            x^     subx   
store(basePG2)      'G'    'g'    U+1D4D 'I'    'i'    U+2071 'm'    'p'    U+1D56 'U'    'u'    U+1D58 U+0289 'x'    U+02E3 U+2093 
store(PG2)          U+0194 U+0263 U+02E0 U+0196 U+0269 U+1DA5 U+00B5 U+0278 U+1DB2 U+01B1 U+028A U+1DB7 U+1D7F U+03C7 U+1D61 U+1D6A 
c
store(basePhGrk)    outs(basePG1) outs(basePG2)  
store(PhGrk)        outs(PG1)     outs(PG2)     

c misc phonetic characters
store(baseIPA-A)  "'"              '|' '-'
store(IPA-A)      outs(saltillo-A) '¦' '¬'
c ANSI stores can't be combined with Unicode, because of a potentially different saltillo
c                                                                    smcapG              ^h
store(baseIPA1)     'B'    'b'    'C'    'c'    'D'    'd'    'G'    U+0262 'g'    'h'    U+02B0 'K'    'k'    'l'    
store(IPA1)         U+0181 U+0253 U+0187 U+0188 U+018A U+0257 U+0193 U+029B U+0260 U+0266 U+02B1 U+0198 U+0199 U+026C 
c                          m^            Eng           eng    n^      eng^                                             
store(baseIPA2)     'm'    U+1D50 'N'    U+014A 'n'    U+014B U+207F  U+1D51 'P'    'p'    'q'    'r'    'S'    's'    
store(IPA2)         U+0271 U+1DAC U+014A U+019D U+014B U+0272 U+1D51  U+1DAE U+01A4 U+01A5 U+02A0 U+027E U+01A9 U+0283   
c                   s^                                 v^                                 z^
store(baseIPA3)     U+02E2 'T'    't'    'V'    'v'    U+1D5B 'Y'    'y'    'Z'    'z'    U+1DBB
store(IPA3)         U+1DB4 U+01AC U+01AD U+01B2 U+028B U+1DB9 U+01B3 U+01B4 U+01B7 U+0292 U+1DBE  
c                   glottals                            length marks  ligatures     
store(baseIPAPunc)  '?'    "'"            '|'    '-'    ':'    '.'    '('    ')'    
store(IPAPunc)      U+0294 outs(saltillo) U+00A6 U+00AC U+02D0 U+02D1 U+203F U+2040 
store(baseIPA)      outs(baseIPA1) outs(baseIPA2) outs(baseIPA3) outs(baseIPAPunc)  
store(IPA)          outs(IPA1)     outs(IPA2)     outs(IPA3)     outs(IPAPunc)  

c letters with curls for indicating palatal-ish sounds
c                           ^c            dz            j^                   esh                  z^     ezh
store(basePalMisc)   'c'    U+1D9C 'd'    U+02A3 'j'    U+02B2 'l'    'n'    U+0283 't'    'z'    U+1DBB U+0292 
store(PalMisc)       U+0255 U+1D9D U+0221 U+02A5 U+029D U+1DA8 U+0234 U+0235 U+0286 U+0236 U+0291 U+1DBD U+0293 


c currency symbols
store(baseCurr-A)   'cLOY' 'Ef'
store(Curr-A)       '¢£¤¥' '€ƒ'
store(baseCurr)     'c'    'E'    'F'    'f'    'L'    'O'    'Y'    
store(Curr)         U+00A2 U+20AC U+20A3 U+0192 U+00A3 U+00A4 U+00A5 

c mathematical symbols
store(baseMath-A)   '+x/0' 'f'  
store(Math-A)       '±×÷°' 'ƒ'
store(baseMath)     '+x/0' 'f'    '-'    '='    '.'    '<'    '>'    'A'    'E'    'e'    'U'    
store(Math)         '±×÷°' U+0192 U+2212 U+2261 U+22C5 U+2264 U+2265 U+2200 U+2203 U+2208 U+222A 

c Left and right quotes and other punctuation characters that come in pairs, plus phonetic symbols
c   that often get typed with the same keys.
c Each of a pair can be switched to the opposite one or straightened out.
store(Quote-A)  '"“”„' "'‘’‚"   
store(LQuote-A) '““““' "‘‘‘‘"   
store(RQuote-A) '””””' "’’’’"      
store(SQuote-A) '""""' "''''"
store(DQuote-A) '„„„„' "‚‚‚‚"
c ANSI stores can't be shared with Unicode, since most of the symbols have different codepoints.
c                       LDbl"   RDbl"   DDbl"              LSgl'   RSgl'   DSgl'                       MLTrn, MLApos 
c store(Quote)  '"'     U+201C  U+201D  U+201E     "'"     U+2018  U+2019  U+201A      outs(saltillo)  U+02BB U+02BC  
c store(LQuote) U+201C  U+201C  U+201C  U+201C     U+2018  U+2018  U+2018  U+2018      U+02BB          U+02BB U+02BB  
c store(RQuote) U+201D  U+201D  U+201D  U+201D     U+2019  U+2019  U+2019  U+2019      U+02BC          U+02BC U+02BC 
c store(SQuote) '"'     '"'     '"'     '"'        "'"     "'"     "'"     "'"         "'"             "'"    "'"     
c store(DQuote) U+201E  U+201E  U+201E  U+201E     U+201A  U+201A  U+201A  U+201A      "'"             "'"    "'"     
c

c directional modifiers (Unicode only)
c                          modifier 
c                          letter 
c                          arrow    half   Dbl    Sgl     
c                   tacks  heads    rings  quotes quotes  Glottals
store(baseDirMod)   '+'    '^'      U+0325 '"'    "'"     outs(saltillo)   
store(Left)         U+0318 U+02C2   U+031C U+201C U+2018  U+02BB           
store(Right)        U+0319 U+02C3   U+0339 U+201D U+2019  U+02BC           
store(Up)           U+031D U+02C4   U+032F '"'    "'"     outs(saltillo)
store(Down)         U+031E U+02C5   U+032E U+201E U+201A  outs(saltillo)

c arrows and other graphical symbols (Unicode only)
c Note that we fudge when the full set of 8 arrows is not available, to make sure that every key combination
c produces something, even if it's not exactly what you'd expect given the key sequence.  
c This makes it easier to code than if we had to enforce strickt interpretations of the sequences and beep for every one for which
c there wasn't a character available.
store(DirMod)       outs(keyLeft) outs(keyDL) outs(keyDown) outs(keyDR) outs(keyRight) outs(keyUR) outs(keyUp) outs(keyUL) 
store(Arrow)        U+2190        U+2199      U+2193        U+2198      U+2192         U+2197      U+2191      U+2196
store(ArrowDbl)     U+21D0        U+21D9      U+21D3        U+21D8      U+21D2         U+21D7      U+21D1      U+21D6
store(ArrowBidi)    U+2194        U+2194      U+2195        U+2195      U+2194         U+2194      U+2195      U+2195
store(ArrowBidiDbl) U+21D4        U+21D4      U+21D5        U+2195      U+21D4         U+21D4      U+21D5      U+21D5
store(CropMark)     U+230D        U+230D      U+230C        U+230C      U+230E         U+230E      U+230F      U+230F

c rotated versions of arrows and arrowheads (Unicode only)
store(BsMLAR)       U+02C2 U+02C5 U+02C3 U+02C4 c modifier letter arrowheads
store(MLAR)         U+02C5 U+02C3 U+02C4 U+02C2 
store(BsAR1)        U+2191 U+2196 U+2190 U+2199 U+2193 U+2198 U+2192 U+2197 c single shaft, single head
store(AR1)          U+2196 U+2190 U+2199 U+2193 U+2198 U+2192 U+2197 U+2191 
store(BsAR2)        U+21D1 U+21D6 U+21D0 U+21D9 U+21D3 U+21D8 U+21D2 U+21D7 c double shaft, single head
store(AR2)          U+21D6 U+21D0 U+21D9 U+21D3 U+21D8 U+21D2 U+21D7 U+21D1 
store(BsARb)        U+2194 U+2195 U+21D4 U+21D5                             c single and double shaft, heads at both ends
store(ARb)          U+2195 U+2194 U+21D5 U+21D4 
store(BsCM)         U+230C U+230E U+230F U+230D
store(CM)           U+230E U+230F U+230D U+230C 
store(baseRotate)   outs(BsMLAR) outs(BsAR1) outs(BsAR2) outs(BsARb) outs(BsCM)
store(Rotate)       outs(MLAR)   outs(AR1)   outs(AR2)   outs(ARb)   outs(CM)

c tone letters (Unicode only)
store(baseToneLetter)   '5'    '4'    '3'    '2'    '1'    
store(ToneLetterR)      U+02E5 U+02E6 U+02E7 U+02E8 U+02E9    c stem on right
store(ToneLetterL)      U+A712 U+A713 U+A714 U+A715 U+A716    c stem on left
store(ToneLetterDR)     U+A708 U+A709 U+A70A U+A70B U+A70C    c dotted, stem on right
store(ToneLetterDL)     U+A70D U+A70E U+A70F U+A710 U+A711    c dotted, stem on left

c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c stores for composite base+diacritic characters 
c PATCH AREA composite 

c This section lists the base characters that should be transformed into composites by the diacritic trigger keys.
c Each diacritic has a base_(diacritic)_ store indicating the base characters to which it can be added, and a 
c _(diacritic)_ store containing the corresponding composite characters.

c Different base stores are required for each diacritic because of the composites available
c Different stores are required for ANSI and Unicode, because
c Unicode has so many more characters than ANSI, and sometimes the codepoints are different
c (for characters in the range 80-9F).

c Ordinary spaces should not be used in the base___ stores in order to generate modifier letters representing the
c diacritic in isolation.  This is because we don't want to encourage the user to think that you
c can type a diacritic on a space.  No-break space should be used instead (as per recommendations in Unicode 4.1.0).
c See below for more discussion where store(ModLtrDiac) is defined.

c U+02DE MODIFIER LETTER RHOTIC HOOK
c                     schwa  rev eps
store(baseRhoticHook) U+0259 U+025C 
store(RhoticHook)     U+025A U+025D 

c U+0300 COMBINING GRAVE ACCENT
store(baseGrave-A)  'A'    'a'    'E'    'e'    'I'    'i'    'O'    'o'    'U'    'u'    
store(Grave-A)      'À'    'à'    'È'    'è'    'Ì'    'ì'    'Ò'    'ò'    'Ù'    'ù'    
c                                                   Abreve abreve               Emacr  emacr                              Omacr  omacr  
store(baseGrave)    outs(baseGrave-A) 'Â'    'â'    U+0102 U+0103 'Ê'    'ê'    U+0112 U+0113 'N'    'n'    'Ô'    'ô'    U+014C U+014D 'Ü'    'ü'    'W'    'w'    'Y'    'y'    
store(Grave)        outs(Grave-A)     U+1EA6 U+1EA7 U+1EB0 U+1EB1 U+1EC0 U+1EC1 U+1E14 U+1E15 U+01F8 U+01F9 U+1ED2 U+1ED3 U+1E50 U+1E51 U+01DB U+01DC U+1E80 U+1E81 U+1EF2 U+1EF3 

c U+0301 COMBINING ACUTE ACCENT
c see also double acute accent, below
store(baseAcute-A)  'A'    'a'    'E'    'e'    'I'    'i'    'O'    'o'    'U'    'u'    'Y'    'y'   
store(Acute-A)      'Á'    'á'    'É'    'é'    'Í'    'í'    'Ó'    'ó'    'Ú'    'ú'    'Ý'    'ý'   
c                                               Abreve abreve AE     ae                   Ccedil ccedil               Emacr  emacr                                            
store(baseAcute1)   'Å'    'å'    'Â'    'â'    U+0102 U+0103 U+00C6 U+00E6 'C'    'c'    U+00C7 U+00E7 'Ê'    'ê'    U+0112 U+0113 'G'    'g'    'Ï'    'ï'    'K'    'k'     
store(Acute1)       U+01FA U+01FB U+1EA4 U+1EA5 U+1EAE U+1EAF U+01FC U+01FD U+0106 U+0107 U+1E08 U+1E09 U+1EBE U+1EBF U+1E16 U+1E17 U+01F4 U+01F5 U+1E2E U+1E2F U+1E30 U+1E31 
c                                                                                         Omacr  omacr  SlashO slasho                             
store(baseAcute2)   'L'    'l'    'M'    'm'    'N'    'n'    'Õ'    'õ'    'Ô'    'ô'    U+014C U+014D U+00D8 U+00F8 'P'    'p'    'R'    'r'    
store(Acute2)       U+0139 U+013A U+1E3E U+1E3F U+0143 U+0144 U+1E4C U+1E4D U+1ED0 U+1ED1 U+1E52 U+1E53 U+01FE U+01FF U+1E54 U+1E55 U+0154 U+0155 
c                                 Utilde utilde                            
store(baseAcute3)   'S'    's'    U+0168 U+0169 'Ü'    'ü'    'W'    'w'    'Z'    'z'    
store(Acute3)       U+015A U+015B U+1E78 U+1E79 U+01D7 U+01D8 U+1E82 U+1E83 U+0179 U+017A
c                                     
store(baseAcute)    outs(baseAcute-A) outs(baseAcute1) outs(baseAcute2) outs(baseAcute3) 
store(Acute)        outs(Acute-A)     outs(Acute1)     outs(Acute2)     outs(Acute3)     

c U+0302 COMBINING CIRCUMFLEX ACCENT
store(baseCirc-A)   'A'    'a'    'E'    'e'    'I'    'i'    'O'    'o'    'U'    'u'    
store(Circ-A)       'Â'    'â'    'Ê'    'ê'    'Î'    'î'    'Ô'    'ô'    'Û'    'û'    
c 
c 
c                                    AdotB  adotB                EdotB  edotB                                            OdotB  odotB  
store(baseCirc)     outs(baseCirc-A) U+1EA0 U+1EA1 'C'    'c'    U+1EB8 U+1EB9 'G'    'g'    'H'    'h'    'J'    'j'    U+1ECC U+1ECD 'S'    's'    'W'    'w'    'Y'    'y'    'Z'    'z'    
store(Circ)         outs(Circ-A)     U+1EAC U+1EAD U+0108 U+0109 U+1EC6 U+1EC7 U+011C U+011D U+0124 U+0125 U+0134 U+0135 U+1ED8 U+1ED9 U+015C U+015D U+0174 U+0175 U+0176 U+0177 U+1E90 U+1E91 

c U+0303 COMBINING TILDE
store(baseTilde-A)  'A'    'O'    'a'    'o'    'N'    'n'    
store(Tilde-A)      'Ã'    'Õ'    'ã'    'õ'    'Ñ'    'ñ'
c                                                    Abreve abreve                                                          
store(baseTilde)    outs(baseTilde-A)  'Â'    'â'    U+0102 U+0103 'E'    'e'    'Ê'    'ê'    'I'    'i'    'Ô'    'ô'    'U'    'u'    'V'    'v'    'Y'    'y'    
store(Tilde)        outs(Tilde-A)      U+1EAA U+1EAB U+1EB4 U+1EB5 U+1EBC U+1EBD U+1EC4 U+1EC5 U+0128 U+0129 U+1ED6 U+1ED7 U+0168 U+0169 U+1E7C U+1E7D U+1EF8 U+1EF9 

c U+0304 COMBINING MACRON
c                                               Adot   adot   AE     ae                                               LdotB  ldotB                                            Odot   odot   Oogonk oogonk RdotB  rdotB                      
store(baseMacron)   'A'    'a'    'Ä'    'ä'    U+0226 U+0227 U+00C6 U+00E6 'E'    'e'    'G'    'g'    'I'    'i'    U+1E36 U+1E37 'O'    'o'    'Ö'    'ö'    'Õ'    'õ'    U+022E U+022F U+01EA U+01EB U+1E5A U+1E5B 'U'    'Ü'    'ü'    'u'    'Y'    'y'     
store(Macron)       U+0100 U+0101 U+01DE U+01DF U+01E0 U+01E1 U+01E2 U+01E3 U+0112 U+0113 U+1E20 U+1E21 U+012A U+012B U+1E38 U+1E39 U+014C U+014D U+022A U+022B U+022C U+022D U+0230 U+0231 U+01EC U+01ED U+1E5C U+1E5D U+016A U+01D5 U+01D6 U+016B U+0232 U+0233 

c U+0306 COMBINING BREVE
c                                 AdotB  adotB                Ecedil ecedil
store(baseBreve)    'A'    'a'    U+1EA0 U+1EA1 'E'    'e'    U+0228 U+0229 'G'    'g'    'I'    'i'    'O'    'o'    'U'    'u'       
store(Breve)        U+0102 U+0103 U+1EB6 U+1EB7 U+0114 U+0115 U+1E1C U+1E1D U+011E U+011F U+012C U+012D U+014E U+014F U+016C U+016D 

c U+0307 COMBINING DOT ABOVE: more composites exist among plus mathematical operators; most not implemented yet
c In the case of 'i' and 'j', this diacritic _removes_ the dot when used with a composite; to get a second dot above, you need to use keyDiac.
store(baseDot1)     'A'    'a'    'B'    'b'    'C'    'c'    'D'    'd'    'E'    'e'    'F'    'f'    'G'    'g'    'H'    'h'    'I'    'i'    'j'    
store(Dot1)         U+0226 U+0227 U+1E02 U+1E03 U+010A U+010B U+1E0A U+1E0B U+0116 U+0117 U+1E1E U+1E1F U+0120 U+0121 U+1E22 U+1E23 U+0130 U+0131 U+0237 
c                                                                                                       Sacute sacute Scaron scaron SdotB  sdotB
store(baseDot2)     'M'    'm'    'N'    'n'    'O'    'o'    'P'    'p'    'R'    'r'    'S'    's'    U+015A U+015B U+0160 U+0161 U+1E62 U+1E63 'T'    't'    'W'    'w'    'X'    'x'    'Y'    'y'    'Z'    'z'    
store(Dot2)         U+1E40 U+1E41 U+1E44 U+1E45 U+022E U+022F U+1E56 U+1E57 U+1E58 U+1E59 U+1E60 U+1E61 U+1E64 U+1E65 U+1E66 U+1E67 U+1E68 U+1E69 U+1E6A U+1E6B U+1E86 U+1E87 U+1E8A U+1E8B U+1E8E U+1E8F U+017B U+017C 
store(baseDot)      outs(baseDot1) outs(baseDot2) 
store(Dot)          outs(Dot1)     outs(Dot2)     

c U+0308 COMBINING DIAERESIS
store(baseDiaerCommon)  'A'    'a'    'E'    'e'    'I'    'i'    'O'    'o'    'U'    'u'    'y'    
store(DiaerCommon)      'Ä'    'ä'    'Ë'    'ë'    'Ï'    'ï'    'Ö'    'ö'    'Ü'    'ü'    'ÿ'       
c 
store(baseDiaer-A)      outs(baseDiaerCommon)  'Y'
store(Diaer-A)          outs(DiaerCommon)      'Ÿ'
c                                                                                 Umacrn umacrn
store(baseDiaer)        outs(baseDiaerCommon)  'H'    'h'    'Õ'    'õ'    't'    U+016A U+016B 'W'    'w'    'X'    'x'    'Y'    
store(Diaer)            outs(DiaerCommon)      U+1E26 U+1E27 U+1E4E U+1E4F U+1E97 U+1E7A U+1E7B U+1E84 U+1E85 U+1E8C U+1E8D U+0178 

c U+030A COMBINING RING ABOVE
store(baseRing-A)   'Aa'
store(Ring-A)       'Åå'
store(baseRing)     outs(baseRing-A) 'U'    'u'    'w'    'y'    
store(Ring)         outs(Ring-A)     U+016E U+016F U+1E98 U+1E99 

c U+030B COMBINING DOUBLE ACUTE ACCENT: 
c                   Oacute oacute UAcute uacute
store(baseAcuteDbl) 'Ó'    'ó'    'Ú'    'ú'    
store(AcuteDbl)     U+0150 U+0151 U+0170 U+0171

c U+030C COMBINING CARON (=hacek, wedge)
store(baseCaron-A)  'SsZz'
store(Caron-A)      'ŠšŽž'
c ANSI stores can't be combined with Unicode because of conflicting codepoints
store(baseCaron1) 'A'    'a'    'C'    'c'    'D'    'd'    'E'    'e'    'G'    'g'    'H'    'h'    'I'    'i'    'j'    'K'    'k'    'L'    'l'    
store(Caron1)     U+01CD U+01CE U+010C U+010D U+010E U+010F U+011A U+011B U+01E6 U+01E7 U+021E U+021F U+01CF U+01D0 U+01F0 U+01E8 U+01E9 U+013D U+013E 
c                                                                                                                                 Ezh    ezh   
store(baseCaron2) 'N'    'n'    'O'    'o'    'R'    'r'    'S'    's'    'T'    't'    'U'    'u'    'Ü'    'ü'    'Z'    'z'    U+01B7 U+0292
store(Caron2)     U+0147 U+0148 U+01D1 U+01D2 U+0158 U+0159 U+0160 U+0161 U+0164 U+0165 U+01D3 U+01D4 U+01D9 U+01DA U+017D U+017E U+01EE U+01EF
store(baseCaron)  outs(baseCaron1) outs(baseCaron2)
store(Caron)      outs(Caron1)     outs(Caron2)     
c With some of these letters, a caron looks like an apostrophe.

c U+030D COMBINING VERTICAL LINE ABOVE: no corresponding composites
c U+030E COMBINING DOUBLE VERTICAL LINE ABOVE: no corresponding composites

c U+030F COMBINING DOUBLE GRAVE ACCENT 
c Most are created by taking a composite with single grave and changing it to a composite with double grave
store(baseGraveDbl) 'À'    'à'    'È'    'è'    'Ì'    'ì'    'Ò'    'ò'    'Ù'    'ù'    
store(GraveDbl)     U+0200 U+0201 U+0204 U+0205 U+0208 U+0209 U+020C U+020D U+0214 U+0215 
c Also allow for the possibility of going from a single grave combining mark on a simple letter to a composite double grave
store(baseGraveDblD) 'A'    'a'    'E'    'e'    'I'    'i'    'O'    'o'    'R'    'r'    'U'    'u'    
store(GraveDblD)     U+0200 U+0201 U+0204 U+0205 U+0208 U+0209 U+020C U+020D U+0210 U+0211 U+0214 U+0215 

c U+0311 COMBINING INVERTED BREVE
store(baseInvBreve) 'A'    'a'    'E'    'e'    'I'    'i'    'O'    'o'    'R'    'r'    'U'    'u'    
store(InvBreve)     U+0202 U+0203 U+0206 U+0207 U+020A U+020B U+020E U+020F U+0212 U+0213 U+0216 U+0217 

c U+0312 COMBINING TURNED COMMA ABOVE (=CEDILLA ABOVE): 
c only one composite, and it's called "cedilla", so it is also implemented with keyCedilla
store(baseCedillaA)   'g'
store(CedillaA)       U+0123

c U+0313 COMBINING COMMA ABOVE: 
c Not sure there are any composites...
store(baseCommaA)
store(CommaA)

c U+0314 COMBINING REVERSED COMMA ABOVE: no corresponding composites; implemented as reversal of 0313
c U+0316 COMBINING GRAVE ACCENT BELOW: no corresponding composites
c U+0317 COMBINING ACUTE ACCENT BELOW: no corresponding composites
c U+0318, U+0319 COMBINING LEFT/RIGHT TACK BELOW: no corresponding composites
c U+031A COMBINING LEFT ANGLE ABOVE: no corresponding composites
c U+031C COMBINING LEFT HALF RING BELOW: no corresponding composites
c U+031D, U+031E COMBINING UP/DOWN TACK BELow: no corresponding composites
c U+031F COMBINING PLUS SIGN BELOW: no corresponding composites
c U+0320 COMBINING MINUS SIGN BELOW: no corresponding composites 

c U+0321 COMBINING PALATAL HOOK BELOW                                                                    
c                                                             ^l                                         esh          t^     
store(basePalHookB) 'b'    'd'    'f'    'g'    'k'    'l'    U+02E1 'm'    'n'    'p'    'r'    's'    U+0283 't'    U+1D57 'v'    'x'    'z'
store(PalHookB)     U+1D80 U+1D81 U+1D82 U+1D83 U+1D84 U+1D85 U+1DAA U+1D86 U+1D87 U+1D88 U+1D89 U+1D8A U+1D8B U+01AB U+1DB5 U+1D8C U+1D8D U+1D8E 

c U+0322 COMBINING RETROFLEX HOOK BELOW
c                              hktp-d        ^l            ^n                   ^s     esh                         ^z     ezh    turned-r's
store(baseRetroHookB1)  'd'    U+0257 'l'    U+02E1 'n'    U+207F 'r'    's'    U+02E2 U+0283 'T'    't'    'z'    U+1DBB U+0292 U+0279 U+02B4
store(RetroHookB1)      U+0256 U+1D91 U+026D U+1DA9 U+0273 U+1DAF U+027D U+0282 U+1DB3 U+1D98 U+01AE U+0288 U+0290 U+1DBC U+1D9A U+027B U+02B5
c                              alpha         open e's      schwa         openo
store(baseRetroHookB2)  'a'    U+0251 'e'    U+025B U+025C U+0259 'i'    U+0254 'u'
store(RetroHookB2)      U+1D8F U+1D90 U+1D92 U+1D93 U+1D94 U+1D95 U+1D96 U+1D97 U+1D99 
store(baseRetroHookB)   outs(baseRetroHookB1) outs(baseRetroHookB2)
store(RetroHookB)       outs(RetroHookB1)     outs(RetroHookB2)
                    
c U+0323 COMBINING DOT BELOW
c                                             Abreve abreve                                                                   
store(baseDotB1)  'A'    'a'    'Â'    'â'    U+0102 U+0103 'B'    'b'    'D'    'd'    'E'    'e'    'Ê'    'ê'    'H'    'h'    'I'    'i'    'K'    'k'    'L'    'l'    'M'    'm'    
store(DotB1)      U+1EA0 U+1EA1 U+1EAC U+1EAD U+1EB6 U+1EB7 U+1E04 U+1E05 U+1E0C U+1E0D U+1EB8 U+1EB9 U+1EC6 U+1EC7 U+1E24 U+1E25 U+1ECA U+1ECB U+1E32 U+1E33 U+1E36 U+1E37 U+1E42 U+1E43 
c                                                                                       SdotA  sdotA
store(baseDotB2)  'N'    'n'    'O'    'o'    'Ô'    'ô'    'R'    'r'    'S'    's'    U+1E60 U+1E61 'T'    't'    'U'    'u'    'V'    'v'    'W'    'w'    'Y'    'y'    'Z'    'z'
store(DotB2)      U+1E46 U+1E47 U+1ECC U+1ECD U+1ED8 U+1ED9 U+1E5A U+1E5B U+1E62 U+1E63 U+1E68 U+1E69 U+1E6C U+1E6D U+1EE4 U+1EE5 U+1E7E U+1E7F U+1E88 U+1E89 U+1EF4 U+1EF5 U+1E92 U+1E93
c
store(baseDotB)   outs(baseDotB1) outs(baseDotB2) 
store(DotB)       outs(DotB1)     outs(DotB2)     
c In addition, four composite characters have macron and dot below, but a composite with macron only does not exist,
c so we have to have a separate rule below that watches for the following with a combining macron.
store(baseMacronDotB) 'L'    'l'    'R'    'r'    
store(MacronDotB)     U+1E38 U+1E39 U+1E5C U+1E5D 

c U+0324 COMBINING DIAERESIS BELOW: only two composites 
store(baseDiaerB)   'U'    'u'    
store(DiaerB)       U+1E72 U+1E73 

c U+0325 COMBINING RING BELOW: 
store(baseRingB) 'A'    'a'    
store(RingB)     U+1E00 U+1E01 
                 
c U+0326 COMBINING COMMA BELOW
c U+0327 COMBINING CEDILLA
c These two are unusual, in that on some composite characters using them the two shapes are considered
c glyph variants, whereas in other cases they contrast.  In particular, a character with the name "cedilla"
c may contain a diacritic that looks like a comma below, and the cedilla combining mark on these characters
c may display as a comma below.  All this depends on the font, and is a result of some European languages
c using them as alternate glyphs for each other.
c So, on those base letters where there is no contrast, we'll key them using either diacritic.  
c In others, they will need to be keyed differently.
c
c First, the base characters in which the two are glyph variants
store(baseCommaCedilla) 'D'    'd'    'G'    'K'    'k'    'L'    'l'    'N'    'n'    'R'    'r'    
store(CommaCedilla)     U+1E10 U+1E11 U+0122 U+0136 U+0137 U+013B U+013C U+0145 U+0146 U+0156 U+0157 
c Second, those that sometimes or always have a diacritic that looks like a comma,
c including all those whose codepoints are named "WITH COMMA BELOW"
store(baseCommaB)   outs(baseCommaCedilla) 'S'    's'    'T'    't'    
store(CommaB)       outs(CommaCedilla)     U+0218 U+0219 U+021A U+021B 
c Third, those whose diacritic is always shaped like a cedilla and a few which have separate composite codepoints
c labelled "WITH COMMA" and "WITH CEDILLA", even though they both look like commas in some fonts.
store(baseCedilla-A) 'Cc'
store(Cedilla-A)     'Çç'
c                    Cacute cacute               Ebreve ebreve
store(baseCedilla1)  U+0106 U+0107 'E'    'e'    U+0114 U+0115 'g'    'H'    'h'    'S'    's'    'T'    't'    
store(Cedilla1)      U+1E08 U+1E09 U+0228 U+0229 U+1E1C U+1E1D U+0123 U+1E28 U+1E29 U+015E U+015F U+0162 U+0163
store(baseCedilla)   outs(baseCommaCedilla) outs(baseCedilla-A) outs(baseCedilla1)
store(Cedilla)       outs(CommaCedilla)     outs(Cedilla-A)     outs(Cedilla1)

c U+0328 COMBINING OGONEK:                                                  
c                                                                           Omacrn omacrn 
store(baseOgonek)   'A'    'a'    'E'    'e'    'I'    'i'    'O'    'o'    U+014C U+014D 'U'    'u'    
store(Ogonek)       U+0104 U+0105 U+0118 U+0119 U+012E U+012F U+01EA U+01EB U+01EC U+01ED U+0172 U+0173

c U+032A COMBINING BRIDGE BELOW: no corresponding composites
c U+032B COMBINING INVERTED DOUBLE ARCH BELOW: no corresponding composites
c U+032C COMBINING CARON BELOW: no corresponding composites

c U+032D COMBINING CIRCUMFLEX ACCENT BELOW: 
store(baseCircB) 'D'    'd'    'E'    'e'    'L'    'l'    'N'    'n'    'T'    't'    'U'    'u'    
store(CircB)     U+1E12 U+1E13 U+1E18 U+1E19 U+1E3C U+1E3D U+1E4A U+1E4B U+1E70 U+1E71 U+1E76 U+1E77 

c U+032E COMBINING BREVE BELOW: 
store(baseBreveB)   'H'    'h'    
store(BreveB)       U+1E2A U+1E2B 

c U+032F COMBINING INVERTED BREVE BELOW: no corresponding composites

c U+0330 COMBINING TILDE BELOW: 
store(baseTildeB) 'E'    'e'    'I'    'i'    'U'    'u'    
store(TildeB)     U+1E1A U+1E1B U+1E2C U+1E2D U+1E74 U+1E75 

c U+0331 COMBINING MACRON BELOW (underlining)
store(baseMacronB-A) '+'    
store(MacronB-A)     '±'  
c                  a^                                                                                  o^                                               
store(baseMacronB) U+1D43 'B'    'b'    'D'    'd'    'h'    'K'    'k'    'L'    'l'    'N'    'n'    U+1D52 'R'    'r'    'T'    't'    'Z'    'z'    '+'    '='    '<'    '>'
store(MacronB)     U+00AA U+1E06 U+1E07 U+1E0E U+1E0F U+1E96 U+1E34 U+1E35 U+1E3A U+1E3B U+1E48 U+1E49 U+00BA U+1E5E U+1E5F U+1E6E U+1E6F U+1E94 U+1E95 U+00B1 U+2261 U+2264 U+2265   

c U+0334 COMBINING TILDE OVERLAY                                                 
c                                                                          fshhkr
store(baseTildeO)  'b'    'd'    'f'    'l'    'm'    'n'    'p'    'r'    U+027E 's'    't'    'z'
store(TildeO)      U+1D6C U+1D6D U+1D6E U+026B U+1D6F U+1D70 U+1D71 U+1D72 U+1D73 U+1D74 U+1D75 U+1D76
                 
c Horizontal stroke = bar
c U+0335 COMBINING SHORT STROKE OVERLAY
c U+0336 COMBINING LONG STROKE OVERLAY
store(baseStroke-A) 'Dd:'     
store(Stroke-A)     'Ðð÷'
c                   smallcapB(x2) B^                          d^                                        smcapI smcapI^ I^     i^     iota                         
store(baseStroke1)  'B'    U+0299 U+1D2E 'b'    'D'    'd'    U+1D48 'G'    'g'    'H'    'h'    'I'    U+026A U+1DA6  U+1D35 'i'    U+2071 U+0269 'j'    U+02B2
store(Stroke1)      U+1D03 U+1D03 U+1D2F U+0180 U+00D0 U+00F0 U+1D9E U+01E4 U+01E5 U+0126 U+0127 U+0197 U+1D7B U+1DA7  U+1DA7 U+0268 U+1DA4 U+1D7C U+025F U+1DA1
c                                               ^o                          ^0     smallcapU(x2)        ^u     upsilon
store(baseStroke2)  'L'    'l'    'O'    'o'    U+1D52 'p'    'T'    't'    U+2070 'U'    U+1D1C 'u'    U+1D58 U+028A 'Z'    'z'    
store(Stroke2)      U+023D U+019A U+019F U+0275 U+1DB1 U+1D7D U+0166 U+0167 U+1DBF U+1D7E U+1D7E U+0289 U+1DB6 U+1D7F U+01B5 U+01B6 
c                   esh    theta         glottals                    div
store(baseStroke3)  U+0283 '0'    '2'    U+0294 '?'    U+0295 U+0296 ':'
store(Stroke3)      U+0284 U+03B8 U+01BB U+02A1 U+02A1 U+02A2 U+01BE U+00F7
c In the above, list 0294 before '?' so that the second keypress results in 0294, not '?'.
c
store(baseStroke)   outs(baseStroke1) outs(baseStroke2) outs(baseStroke3)
store(Stroke)       outs(Stroke1)     outs(Stroke2)     outs(Stroke3)
c
c Deliberately not currently supported:
c U+0110 LATIN CAPITAL LETTER D WITH STROKE     to avoid conflict with U+00D0 LATIN CAPITAL LETTER ETH
c U+0111 LATIN SMALL LETTER D WITH STROKE       to avoid conflict with U+00F0 LATIN SMALL LETTER ETH 
c
c Deliberately not implemented as a stroke:
c U+019B LATIN SMALL LETTER LAMBDA WITH STROKE  implemented as a ligature of tl

c Diagonal solidus = slash
c U+0337 COMBINING SHORT SOLIDUS OVERLAY
c U+0338 COMBINING LONG SOLIDUS OVERLAY
c also currently used for IPA flat fricatives that correspond to Americanist symbols with stroke and certain palatals
c The ANSI c-slash uses the cent sign, which is a fudge.
store(baseSlash-A)  'cOo'     
store(Slash-A)      '¢Øø'                               
c                                               smallL                      Oacute oacute
store(baseSlash1)   'A'    'C'    'c'    'L'    U+029F 'l'    'O'    'o'    'Ó'    'ó'    'T' 
store(Slash1)       U+023A U+023B U+023C U+0141 U+1D0C U+0142 U+00D8 U+00F8 U+01FE U+01FF U+023E 
c                                 quant  element
store(baseSlash2)   '0'    '='    U+2203 U+2208
store(Slash2)       U+2205 U+2260 U+2204 U+2209
store(baseSlash)    outs(baseSlash1) outs(baseSlash2)
store(Slash)        outs(Slash1)     outs(Slash2)

c U+0339 COMBINING RIGHT HALF RING BELOW: no corresponding composites
c U+033A COMBINING INVERTED BRIDGE BELOW: no corresponding composites
c U+033B COMBINING SQUARE BELOW: no corresponding composites
c U+033C COMBINING SEAGULL BELOW: no corresponding composites
c U+033D COMBINING X ABOVE: no corresponding composites

c U+0346 COMBINING BRIDGE ABOVE: no corresponding composites

c U+0348 COMBINING DOUBLE VERTICAL LINE BELOW: no corresponding composites
c U+0349 COMBINING LEFT ANGLE BELOW: no corresponding composites

c U+0351 COMBINING LEFT HALF RING ABOVE: no corresponding composites

c U+0353 COMBINING X BELOW: no corresponding composites

c U+0357 COMBINING RIGHT HALF RING ABOVE: no corresponding composites

c U+035C COMBINING DOUBLE BREVE BELOW: no corresponding composites
c U+035D COMBINING DOUBLE BREVE: no corresponding composites
c U+035E COMBINING DOUBLE MACRON: no corresponding composites 
c U+035F COMBINING DOUBLE MACRON BELOW: no corresponding composites 

c U+0361 COMBINING DOUBLE INVERTED BREVE: no corresponding composites

c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c base characters that accept combining marks
c PATCH AREA baseCom

c For visible trigger keys used by themselves (not with keyDiac) and which introduce combining marks, 
c it can be helpful to limit them so they only generate combining marks with certain base characters.  
c That way, you can avoid introducing combining marks when people intend to type something else.  
c
c List in the stores below the base characters that can appear with each combining mark, then make use of these stores
c later at "PATCH AREA individual diacritics" (see instructions there).
c For example:
c store(baseComGrave)         U+0197 U+0268 U+00C6 U+00E6         c U+0300 COMBINING GRAVE ACCENT
c
c Not all diacritics require these stores.
c If there are diacritics that are always represented with combining marks OR whose trigger
c key is not likely to be typed by itself (e.g. because it is an invisible CTRL combination), 
c then it may not be necessary to provide a base store for them.
c IS THIS TRUE? NEED TO THINK THROUGH ALL THE DIFFERENT TYPES OF TRIGGER KEYS AND SEQUENCES, AND WHETHER THEY NEED 
c baseCom STORES FOR ANY REASON.  
c Many are listed below in comments anyway, for convenience in adding this feature if necessary, but I haven't
c attempted to maintain a complete list of diacritics here.
c
c If you are concerned about being able to type diacritics in isolation, do not attempt to include spaces or no-break spaces
c in the baseCom stores.  For one thing, it probably wouldn't be effective, and it might actually interfere with
c later code that handles diacritics in isolation.  See "PATCH AREA diacritics in isolation".
c 
c 2005-03-25: In the current version of the keyboard, it is only necessary (and only helpful) to list base characters here
c   which are not listed in the diacritic's base_(diacritic)_ store above.  If there is a composite, it will be introduced, 
c   whether the user wants it or not.  So, to block an unwanted change to a composite you have to remove the base character and the
c   composite from the appropriate base_(diacritic)_ and _(diacritic)_ stores above.
c   But, if I ever change the keyboard so that combining marks are always introduced first
c   and only later collapsed to composites, then this section of the code could be used 
c   to block unwanted composites from being produced too.  That is, the keyboard could be easily modified
c   so as not to produce any change for a particular combination of base + trigger key, neither to a combining mark or 
c   a composite character, simply by not listing the base character here.  There would be no need to remove the base character 
c   and the composite from the base_(diacritic)_ and _(diacritic)_ stores above.  It would provide a more centralized, consistent, 
c   and easily modifiable way to add or subtract base+diacritic combinations from the keyboard.
c   On the other hand, wouldn't that *require* one to list a new base character in both stores, at least if the baseCom store
c   was used at all? That doesn't sound like an improvement!
c 
c Certain base characters may occur frequently in the following stores; so there are abbreviations for them here:
store(iWithStroke)  U+0197 U+0268   c barred-i, u.c. and l.c. 
store(ae)           U+00C6 U+00E6   c ae ligature, u.c. and l.c.
store(vowelLC)      'aeiou' U+0268 U+00E6 c basic lower case vowels
store(vowelUC)      'AEIOU' U+0197 U+00C6 c basic upper case vowels
c
c                       SUPPORTED
c STORE                 BASE CHARS                                  COMBINING DIACRITIC
c U+0300 COMBINING GRAVE ACCENT
c U+0301 COMBINING ACUTE ACCENT
c U+0302 COMBINING CIRCUMFLEX ACCENT
store(baseComTilde)     outs(iWithStroke) outs(ae)                  c U+0303 COMBINING TILDE
c U+0304 COMBINING MACRON
c U+0306 COMBINING BREVE
c U+0308 COMBINING DIAERESIS
c U+030C COMBINING CARON
c U+0311 COMBINING INVERTED BREVE
c U+031F COMBINING PLUS SIGN BELOW (IPA advanced)
c U+0320 COMBINING MINUS SIGN BELOW (IPA retracted)
c U+0323 COMBINING DOT BELOW (Americanist retroflexed)
c U+0324 COMBINING DIAERESIS BELOW (IPA breathy voice)
c U+0325 COMBINING RING BELOW (IPA voiceless) 
c U+032C COMBINING CARON BELOW 
c U+032E COMBINING BREVE BELOW
c U+032F COMBINING INVERTED BREVE BELOW (Americanist fronted articulation)    
store(baseComTildeB)    outs(vowelLC) outs(vowelUC)                 c U+0330 COMBINING TILDE BELOW (creaky voice)
c U+0331 COMBINING MACRON BELOW ("underlined" vowels)
c U+035D COMBINING DOUBLE BREVE
c U+0361 COMBINING DOUBLE INVERTED BREVE (ligature tie)

c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c Stores for diacritics in isolation

c Some base characters should never be followed by combining marks.
c This store shouldn't normally need to be changed, unless you want to add other characters that you
c don't want to accidentally pu diacritics on (e.g. digits, punctuation, symbols, modifier letters).
c                       space  
store(baseComIllegal)   " "   
c PROBLEMS: 
c I can't seem to get CR, LF, or TAB into this list using Unicode codepoints.
c I *can* get them in as virtual keys, but they don't seem to match anything in the context in the later code that tries 
c   to use them; maybe control characters are not put into the context.
c At any rate, it looks like we can't use this mechanism to prevent combining marks from going on CR, LF, or TAB, 
c   and probably other control characters.

c To generate modifier letter diacritics and other spacing diacritics, we're not treating them the same as composite characters,
c using the base_(diacritic)_ and _(diacritic)_ stores, but rather handling all of them as a distinct set.  Reasons:
c 1) To generate modifier letters using keyDiac in an approach that treated them exactly like composite characters, 
c    we'd have to implement support for composites with keyDiac, either adding rules for keyDiac 
c    for a couple dozen diacritics, several of which would not need rules for composites except for this one modifier letter.
c    Either that, or move all handling of composites to a separate group.  Either way, this would be a pretty 
c    major set of changes, one that I'm not convinced is all that important for most letter+diacritic combinations.
c    That is, combining marks are supposed to behave exactly the same as composites, so it really shouldn't matter,
c    and when it does matter now, it's mostly because the standard isn't fully implemented, so it will matter less and less
c    as time goes on.
c 2) But, it *is* important to provide support for modifier letter diacritics, and to prefer them to using combining marks.  
c    The reason is that Word (and perhaps other applications) do not treat no-break space plus a combining mark as a 
c    composite character, for the purpose of cursor movement and the DELETE key.  
c 3) This, in turn, is probably related to the fact that Unicode does not provide canonical decompositions for modifier letter
c    diacritics, so there is no requirement to treat no-break space plus a combining mark as a single character.  And, this
c    could have ramifications in other applications too.    
c Thus, we have a separate pair of stores to handle all modifier letter diacritics as one unified set, 
c independent of the composite characters.

c Based on a suggestion by Lorna Priest (2005-03-22), when there are spacing diacritics both in Latin-1 and in the modifier
c letter block, we'll use the modifier letters, assuming the ones in the Latin-1 are there primarily for compatibility with 
c the older standard.  But, of course, for the ANSI keyboard, we need to use to use the ones
c in Latin-1.

c don't include U+02BE, U+02BF, U+02D2, U+02D3 (half-rings); they aren't considered equivalent to the combining marks
store(TMLDCa)   outs(keyCirc) outs(keyCaron) outs(keyMacron) outs(keyAcute) outs(keyGrave) 
store(MLDCa)    U+02C6        U+02C7         U+02C9          U+02CA         U+02CB         
store(TMLDCb)   outs(keyMacronB) outs(keyGraveB) outs(keyAcuteB)
store(MLDCb)    U+02CD           U+02CE          U+02CF 
c don't include U+02D4 and U+02D5 (up/down tacks); they aren't considered equivalent to the combining marks
c don't include U+02D6 and U+02D7 (plus and minus); they aren't considered equivalent to the combining marks
store(TMLDDa)   outs(keyBreve) outs(keyDot) outs(keyRing) outs(keyOgonek) outs(keyTilde)  
store(MLDDa)    U+02D8         U+02D9       U+02DA        U+02DB          U+02DC         
c don't include keyDblAcute (U+02DD) because that store isn't currently defined  
store(TMLDEF)   outs(keyCaronB) outs(keyRingB) outs(keyTildeB)
store(MLDEF)    U+02EC          U+02F3         U+02F7 
c Don't include U+02DE MODIFIER LETTER RHOTIC HOOK. It's already a modifier letter, even though we type it as 
c if it were a diacritic. So, when used in apparent isolation, we need to keep the no-break space in front of it.
c
store(Trig4ModLtrDiac) outs(TMLDCa) outs(TMLDCb) outs(TMLDDa) outs(TMLDEF) 
store(ModLtrDiac)      outs(MLDCa)  outs(MLDCb)  outs(MLDDa)  outs(MLDEF)                              
c
c The following are the equivalent for the ANSI keyboard
store(Trig4SpacingDiac-A) outs(keyCirc) outs(keyTilde) outs(keyGrave) outs(keyDiaer) outs(keyMacron) outs(keyAcute) outs(keyCedilla)
store(SpacingDiac-A)      'ˆ'           '˜'            '`'            '¨'            '¯'             '´'            '¸' 






c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Main processing (Unicode)
c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
store(&TARGETS) 'windows macosx'
store(&KEYBOARDVERSION) '2.0'

begin Unicode > use(main)
group(main) using keys

c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Diacritics in apparent isolation

c Block diacritics after ordinary space and other illegal characters, regardless of whether they are
c typed with keyDiac or with single triggers.  This code won't prevent all cases of this sort;
c there are probably lots of things the user could do to get around these restrictions.  But,
c this should be helpful to screen out accidental insertion of combining marks.
  c Discard any invisible trigger keys in this context.
    any(baseComIllegal)                 + any(InvisibleTrigger)    > context beep
    any(baseComIllegal) outs(keyDiac)   + any(InvisibleTrigger)    > context beep
  c Visible trigger keys should not be discarded, but rather passed to the output unchanged.
    c When they are used without keyDiac, this is accomplished by not including space etc. in the baseCom store for the diacritic.
    c   Don't try to block it here; a rule here would probably be of the same weight as the rules that invoke the baseCom_(diacitic)_ stores,
    c   and thus the attempt might be in vain.  Rather, rely on warnings not to put space in baseCom_(diacritic)_
    c When they follow keyDiac, we have to do something special here to block the general invocation of the keyDiac rule.
    any(baseComIllegal) outs(keyDiac)   + any(VisibleTrigger)      > context index(VisibleTrigger,3)   
c Also attempt to block combining marks when the context is unknown or at the beginning of the file. 
c (DOESN'T SEEM TO WORK IN KEYMAN 6.0.155.0, BUT MIGHT GET FIXED LATER.)
    nul                 + any(InvisibleTrigger) > beep
    nul outs(keyDiac)   + any(InvisibleTrigger) > context beep  
    nul outs(keyDiac)   + any(VisibleTrigger)   > context index(VisibleTrigger,3)

c On the other hand we DO allow diacritics after no-break space; that's how we get diacritics in apparent isolation.
c Some of these may actually be encoded as spacing diacritics or modifier letter diacritics, others as combining marks.

c However, normally we will require keyDiac in order to get diacritics in isolation, rather than using trigger keys by themselves.
c This way, we can avoid introducing combining marks or modifier letters when what the user may want is the 
c ordinary character from a visible trigger key, such as apostrophe, immediately after a no-break space.
    c PATCH AREA diacritics in isolation 
    c   If you want to be able to use single trigger keys with no-break space to type diacritics in isolation, 
    c     comment out the next two lines.
    c   If you want to require use of keyDiac, use the next two lines.
    c   If you make change here, also make a change at "PATCH AREA diacritics in isolation ANSI"
    outs(nbsp) + any(InvisibleTrigger)  > context beep
    outs(nbsp) + any(VisibleTrigger)    > context index(VisibleTrigger,2)
c Two comments about how these two rules work:
c a) They must take precedence over the rules that use single trigger keys
c    to generate modifier letters and the general rules that introduce combining marks at 1st keypress.
c    Thus, they must come before those other rules in the source code.
c b) It is not sufficient to rely on the absence of no-break space in the baseCom stores 
c    to block the special meaning of visible trigger keys. That only blocks insertion
c    of combining marks, and we also need to block insertion of modifier letters.
c    The above rule does both.
        
c Generate modifier letters rather than using combining marks for diacritics in isolation, whenever they are available.
c a. See discussion above, where the store ModLtrDiac is defined, as to why we take this approach rather than
c    treating modifier letter diacritics as composite characters.
c b. In this section, we provide for typing the modifier letter either with our without keyDiac.
c    Just because things are coded this way here, however, doesn't mean that the first rule will actually work,
c    because there are other rules that interfere with it.  (See above at "PATCH AREA diacritics in isolation".)
outs(nbsp)                  + any(Trig4ModLtrDiac)  > index(ModLtrDiac,2)
outs(nbsp) outs(keyDiac)    + any(Trig4ModLtrDiac)  > index(ModLtrDiac,3)
any(ModLtrDiac)             + [K_BKSP]              > outs(nbsp)
c 
c Providing general 2nd keypress behavior (like that for ordinary uses of diacritics typed with single trigger keys)
c is problematic.  The following sort of thing will not work, because it does not require the trigger key to be the one
c that corresponds to the modifier letter.  (It would be nice to be able to use index() on the left side of the rule, 
c but that is not syntactically allowed.)  As a result, visible triggers like "x" and "n" at the beginning
c of the next word will replace any modifier letter with a no-break space.
c any(ModLtrDiac)            + any(InvisibleTrigger) > outs(nbsp)
c any(ModLtrDiac)            + any(VisibleTrigger)   > outs(nbsp) index(VisibleTrigger,2)
c The above are an attempt to have the 2nd keypress reverse the effect of the first keypress; similar problems would arise
c if we just wanted to ignore a 2nd keypress.
c The only way around the problem would be to list every specific combination of modifier letter and diacritic here--
c probably not worth the bother.                        
c 
c But, we *do* need the special 2nd keypress behavior for double diacritics:
U+02CA              + any(keyAcute) > U+02DD    c 2nd keypress: single to double acute (modifier letter)
U+02DD              + [K_BKSP]      > U+02CA    c backspace: double back to single
c NB: there is no modifier letter for double grave, except a middle height one, but we've generally avoided the middle-height
c   modifier letters
c Oddly, in Doulos SIL Text, the combining mark is higher on a nbsp 
c   than on an ordinary lower-case letter in TIKE, and higher than other modifier letters, but in Word the 
c   combining mark is at the right height: the same as the other modifier letters and its height on a lower-case letter.
c   In contrast, U+02F5 MODIFIER LETTER MIDDLE DOUBLE GRAVE ACCENT is too low in both programs,
c   as is the middle double acute accent.
c So, it looks like we should use nbsp plus the combining mark for double grave by itself.
U+02CB              + any(keyGrave) > outs(nbsp) U+030F     c 2nd keypress: single to double grave (modifier letter)
outs(nbsp) U+030F   + [K_BKSP]      > U+02CB
c 
c And certainly, it is not important to provide 3rd keypress behavior for visible triggers: How many times would a person want
c a modifier letter immediately followed by its corresponding visible trigger key?  Very rarely.




c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Diacritics with ordinary letters (both composite and combining)

c combining marks by means of keyDiac
outs(keyDiac)                                   + any(DiacTrig)     > index(CombMark,2)               
c Don't provide any workaround changes for 2nd and 3rd instances of the trigger; 
c the combinations should be so rare as to not be needed normally,
c so there's no need to complicate the keyboard to provide them.
c But, if we ever reactivate the following code, we will probably need to distinguish between visible and invisible triggers
c after two instances of keyDiac.
c outs(keyDiac) outs(keyDiac)                     + any(DiacTrig)     > outs(keyDiac) index(DiacTrig,3)
c outs(keyDiac) outs(keyDiac) outs(keyDiac)       + any(DiacTrig)     > outs(keyDiac) index(CombMark,4)


c INSTRUCTIONS FOR PATCHING DIACRITIC RULES 
c 
c Separate rules are required for the 1st, 2nd, and sometimes the 3rd keypress of the trigger key.
c Typing the trigger key a second time should remove the diacritic, plus insert any visible trigger key.
c For visible triggers, a 3rd keypress should result in the diacritic being reinserted, in addition to retaining
c the normal output from the trigger key that was inserted by the 2nd keypress rule.
c
c How you write these rules depends on whether the trigger character is visible or invisible.
c In addition, you sometimes need to provide for keyDiac sequences here.

c To process a visible trigger key, follow this pattern:
c any(baseGrave)                   + outs(keyGrave)        > index(Grave,1)                       c 1st keypress, composite
c any(Grave)                       + [K_BKSP]              > index(baseGrave,1)                   c backspace after composite, mimics behavior of backspace after combining mark
c any(Grave)                       + outs(keyGrave)        > index(baseGrave,1)    outs(keyGrave) c 2nd keypress, composite
c any(baseGrave)    outs(keyGrave) + outs(keyGrave)        > index(Grave,1)        outs(keyGrave) c 3rd keypress, composite
c any(baseComGrave)                + outs(keyGrave)        > context   U+0300                     c 1st keypress, combining
c U+0300                           + outs(keyGrave)        >                       outs(keyGrave) c 2nd keypress, combining
c any(baseComGrave) outs(keyGrave) + outs(keyGrave)        > context(1) U+0300     outs(keyGrave) c 3rd keypress, combining
c
c Note that, if visible trigger keys are used to generate combining marks, you should establish a store(baseCom_(diacritic)_)
c for them for use on the rules for 1st and 3rd keypress, so that they are only interpreted as trigger keys following 
c certain base characters and definitely not following an ordinary space.  See above at "PATCH AREA baseCom". 


c To process an invisible trigger key, follow this pattern:
c any(baseGrave)          + outs(keyGrave)        > index(Grave,1)        c 1st keypress, composite
c any(Grave)              + [K_BKSP]              > index(baseGrave,1)    c backspace after composite, mimics behavior of backspace after combining mark
c any(Grave)              + outs(keyGrave)        > context beep          c 2nd keypress, composite
c                         + outs(keyGrave)        > U+0300                c 1st keypress, combining
c U+0300                  + outs(keyGrave)        > context beep          c 2nd keypress, combining   
c
c Note that, there is no need for a baseCom_(diacritic)_ store to restrict the insertion of combining marks. 
c Indeed, combining marks *should* be inserted across-the-board, without regard to the preceding character,
c when the trigger key is invisible; if the invisible trigger character is typed 
c but not translated to a diacritic, it may be introduced into the data stream as an invisible 
c character and sent to the application, causing strange behavior.  
c
c The above code has the effect of ignoring the second keypress and beeping to alert the user that it
c has done so.  Alternately, you could code the 2nd keypress behavior 
c in a way that the effect of the trigger key is reversed, the same as if the backspace key is pushed.
c any(Grave)              + outs(keyGrave)        > index(baseGrave,1)    c 2nd keypress, composite
c U+0300                  + outs(keyGrave)        > nul                   c 2nd keypress, combining   
c 
c There is no need to provide 3rd keypress behavior for invisible trigger keys, because an instance of 
c the trigger key should never get put into the context (at least, if the above code works as intended).
c
c Actually, a couple of diacritics have double versions, in which the 2nd keypress is used to generate the double version 
c of the diacritic; in such cases, it is the 3rd keypress that must be ignored.  (In fact, grave accent is one of those, so 
c the actual code for the grave accent below does not follow the above pattern.)


c keyDiac sequences for composites
c
c In addition to the above options, we sometimes need to handle sequences of keyDiac plus the trigger key.
c Most keyDiac sequences generate combining marks, and when they do, they are handled by code above
c that selects the correct combining mark using the CombMark store.
c However, if you want keyDiac to generate composites, you have to include additional rules in this block that watch for 
c the keyDiac sequence.  Such lines are just like the examples for the 1st keypress, but with outs(keyDiac) before the "+".
c 
c There shouldn't be any need to provide special processing for a second or third instance
c of a keyDiac sequence.  The keyDiac sequence should be a rare enough sequence that there
c is no need for a special workaround for it.  Besides, by not providing any special 2nd 
c keypress behavior, keyDiac can be used to stack two instances of the same diacritic, if that's ever necessary.


c PATCH AREA individual diacritics
c See instructions above

c rhotic hook
any(baseRhoticHook) outs(keyDiac)   + outs(keyRhoticHook)   > index(RhoticHook,1)
any(RhoticHook)                     + [K_BKSP]              > index(baseRhoticHook,1)   
c rhotic hook combining, see store(CombMark)

c grave U+0300 and double grave U+030F 
c For explanations of the code, see the comments for acute and double acute below.
any(baseGrave)                      + outs(keyGrave)        > index(Grave,1)        
any(Grave)                          + [K_BKSP]              > index(baseGrave,1)   
any(baseGraveDbl)                   + outs(keyGrave)        > index(GraveDbl,1)
any(GraveDbl)                       + [K_BKSP]              > index(baseGraveDbl,1)
any(Grave)                          + outs(keyGrave)        > index(baseGrave,1) U+030F
any(baseGrave) U+030F               + [K_BKSP]              > index(Grave,1)
                                    + outs(keyGrave)        > U+0300     
               U+0300               + outs(keyGrave)        > U+030F
               U+030F               + [K_BKSP]              > U+0300     
any(baseGraveDblD) U+0300           + outs(keyGrave)        > index(GraveDblD,1)              c single combining to double composite
any(GraveDblD)                      + [K_BKSP]              > index(baseGraveDblD,1) U+0300   c and back; only applies if there is not a single composite
any(GraveDbl)                       + outs(keyGrave)        > context beep
               U+030F               + outs(keyGrave)        > context beep
any(GraveDblD)                      + outs(keyGrave)        > context beep                  c 3rd keypress on doubles derived from single combining

c acute U+0301 and double acute U+030B
any(baseAcute)                      + outs(keyAcute)        > index(Acute,1)                c 1st keypress: single acute composite
any(Acute)                          + [K_BKSP]              > index(baseAcute,1)            c backspace: undoes 1st keypress
any(baseAcuteDbl)                   + outs(keyAcute)        > index(AcuteDbl,1)             c 2nd keypress: single composite to double composite
any(AcuteDbl)                       + [K_BKSP]              > index(baseAcuteDbl,1)         c backspace: undoes 2nd keypress, back to single composite
any(Acute)                          + outs(keyAcute)        > index(baseAcute,1) U+030B     c 2nd keypress: single composite to double combining
any(baseAcute) U+030B               + [K_BKSP]              > index(Acute,1)                c backspace: undoes 2nd keypress, back to single composite
                                    + outs(keyAcute)        > U+0301                        c 1st keypress: single combining
                                                                                            c backspace: erases the single combining automatically (no need to write a rule)
               U+0301               + outs(keyAcute)        > U+030B                        c 2nd keypress: single combining to double combining
               U+030B               + [K_BKSP]              > U+0301                        c backspace: undoes 2nd keypress, back to single combining
any(AcuteDbl)                       + outs(keyAcute)        > context beep                  c 3rd keypress on composite: error
               U+030B               + outs(keyAcute)        > context beep                  c 3rd keypress on combining: error
c
c The use of keyAcute twice to get the double acute will make it unwise to use a visible trigger key for keyAcute (e.g. apostrophe),
c because the 2nd keypress can't output base character plus keyAcute.  So, either you'd have to find some other way to 
c keyboard the double acute, or you'd forego the ability to easily output base character plus keyAcute.  
c Actually, though, you wouldn't want to output keyAcute itself on the 2nd keypress, because of the problem
c that apostrophe may also be used for typing dotless exclamation (see comments above at PATCH AREA acute and saltillo).
c So, what you'd actually have is something like this leftover old code:
c any(Acute)                            + outs(keyAcute)        > index(baseAcute,1)    outs(nrmlRsltAcute)  c 2nd keypress, composite
c any(baseAcute)    outs(nrmlRsltAcute) + outs(keyAcute)        > index(Acute,1)        outs(nrmlRsltAcute)  c 3rd keypress, composite
c U+0301                                + outs(keyAcute)        >                       outs(nrmlRsltAcute)  c 2nd keypress, combining
c any(baseComAcute) outs(nrmlRsltAcute) + outs(keyAcute)        > context(1) U+0301     outs(nrmlRsltAcute)  c 3rd keypress, combining
c This extra problem with the ambiguity of apostrophe for acute accent and saltillo is another reason not to use ordinary apostrophe
c for keyAcute.

c circumflex
any(baseCirc)                       + outs(keyCirc)         > index(Circ,1)     
any(Circ)                           + [K_BKSP]              > index(baseCirc,1)   
any(Circ)                           + outs(keyCirc)         > context beep
                                    + outs(keyCirc)         > U+0302 
U+0302                              + outs(keyCirc)         > context beep

c tilde (visible trigger key)
any(baseTilde)                      + outs(keyTilde)        > index(Tilde,1)        
any(Tilde)                          + [K_BKSP]              > index(baseTilde,1)   
any(Tilde)                          + outs(keyTilde)        > index(baseTilde,1)    outs(keyTilde)
any(baseTilde) outs(keyTilde)       + outs(keyTilde)        > index(Tilde,1)        outs(keyTilde)
any(baseComTilde)                   + outs(keyTilde)        > context   U+0303     
U+0303                              + outs(keyTilde)        >                       outs(keyTilde)
any(baseComTilde) outs(keyTilde)    + outs(keyTilde)        > context(1) U+0303     outs(keyTilde)

c macron
any(baseMacron)                     + outs(keyMacron)       > index(Macron,1)       
any(Macron)                         + [K_BKSP]              > index(baseMacron,1)   
any(Macron)                         + outs(keyMacron)       > context beep
                                    + outs(keyMacron)       > U+0304     
U+0304                              + outs(keyMacron)       > context beep

c breve U+0306
any(baseBreve)                      + outs(keyBreve)        > index(Breve,1)      
any(Breve)                          + [K_BKSP]              > index(baseBreve,1)   
any(Breve)                          + outs(keyBreve)        > context beep
                                    + outs(keyBreve)        > U+0306   
U+0306                              + outs(keyBreve)        > context beep

c dot above U+0307
any(baseDot)                        + outs(keyDot)          > index(Dot,1)      
any(Dot)                            + [K_BKSP]              > index(baseDot,1)   
any(Dot)                            + outs(keyDot)          > context beep
                                    + outs(keyDot)          > U+0307  
U+0307                              + outs(keyDot)          > context beep

c diaeresis
any(baseDiaer)                      + outs(keyDiaer)        > index(Diaer,1)        
any(Diaer)                          + [K_BKSP]              > index(baseDiaer,1)   
any(Diaer)                          + outs(keyDiaer)        > context beep
                                    + outs(keyDiaer)        > U+0308      
U+0308                              + outs(keyDiaer)        > context beep

c ring
any(baseRing)                       + outs(keyRing)         > index(Ring,1)         
any(Ring)                           + [K_BKSP]              > index(baseRing,1)   
any(Ring)                           + outs(keyRing)         > context beep
                                    + outs(keyRing)         > U+030A      
U+030A                              + outs(keyRing)         > context beep

c double acute U+030B: see above under acute, using a second keypress of keyAcute
c The old approach was to have a separate trigger key for double acute, thus:
c                                     + outs(keyDblAcute)     > U+030B      
c U+030B                              + outs(keyDblAcute)     > context beep

c caron
any(baseCaron)                      + outs(keyCaron)        > index(Caron,1)        
any(Caron)                          + [K_BKSP]              > index(baseCaron,1)   
any(Caron)                          + outs(keyCaron)        > context beep
                                    + outs(keyCaron)        > U+030C      
U+030C                              + outs(keyCaron)        > context beep

c double grave U+030F: see above under grave, using a second keypress of keyGrave
c Here is the old approach:
c                                     + outs(keyDblGrave)     > U+030F      
c U+030F                              + outs(keyDblGrave)     > context beep

c inverted breve U+0311
any(baseInvBreve)                   + outs(keyInvBreve)     > index(InvBreve,1)        
any(InvBreve)                       + [K_BKSP]              > index(baseInvBreve,1)   
any(InvBreve)                       + outs(keyInvBreve)     > context beep
                                    + outs(keyInvBreve)     > U+0311      
U+0311                              + outs(keyInvBreve)     > context beep

c turned comma above (=cedilla above) U+0312
c Actually, there is only one composite (U+0123), but for completeness we should include it, and it's just as easy
c to implement it generally.
any(baseCedillaA)                   + outs(keyCedillaA)     > index(CedillaA,1)        
any(CedillaA)                       + [K_BKSP]              > index(baseCedillaA,1)   
any(CedillaA)                       + outs(keyCedillaA)     > context beep
                                    + outs(keyCedillaA)     > U+0312
U+0312                              + outs(keyCedillaA)     > context beep
c Since this diacritic can also be generated by turning a comma above, we need to watch for that possibility in order to 
c generate the composite character(s).
any(baseCedillaA) U+0313            + outs(keyTurn)         > index(CedillaA,1)
c turned comma above combining, see store(CombMark)

c comma above U+0313,  requires keyDiac
c any(baseCommaA)   outs(keyDiac)     + outs(keyCommaA)       > index(CommaA,1)        
c any(CommaA)                         + [K_BKSP]              > index(baseCommaA,1)   

c grave below
c no composites
                                    + outs(keyGraveB)       > U+0316      
U+0316                              + outs(keyGraveB)       > context beep

c acute below
c no composites
                                    + outs(keyAcuteB)       > U+0317      
U+0317                              + outs(keyAcuteB)       > context beep

c left angle above combining, requires keyDiac, see store(CombMark)

c plus sign below combining U+031F, requires keyDiac, see store(CombMark)

c minus sign below combining U+0320, requires keyDiac, see store(CombMark)

c palatal hook below U+0321, requires keyDiac 
any(basePalHookB)   outs(keyDiac)   + outs(keyPalHookB)     > index(PalHookB,1)     
any(PalHookB)                       + [K_BKSP]              > index(basePalHookB,1)   
c palatalized hook below combining, see store(CombMark)

c retroflex hook below U+0322, requires keyDiac 
any(baseRetroHookB) outs(keyDiac)   + outs(keyRetroHookB)   > index(RetroHookB,1)   
any(RetroHookB)                     + [K_BKSP]              > index(baseRetroHookB,1)   
                                                                                    

c dot below U+0323
any(baseDotB)                       + outs(keyDotB)         > index(DotB,1)         
any(DotB)                           + [K_BKSP]              > index(baseDotB,1)   
any(DotB)                           + outs(keyDotB)         > context beep
                                    + outs(keyDotB)         > U+0323      
U+0323                              + outs(keyDotB)         > context beep
c In addition, at least four characters have macron with dot below, but no composite exists for the macron alone.
any(baseMacronDotB) U+0304          + outs(keyDotB)         > index(MacronDotB,1)         

c diaeresis below U+0324
any(baseDiaerB)                     + outs(keyDiaerB)       > index(DiaerB,1)         
any(DiaerB)                         + [K_BKSP]              > index(baseDiaerB,1)   
any(DiaerB)                         + outs(keyDiaerB)       > context beep
                                    + outs(keyDiaerB)       > U+0324      
U+0324                              + outs(keyDiaerB)       > context beep

c ring below U+0325
any(baseRingB)                      + outs(keyRingB)        > index(RingB,1)         
any(RingB)                          + [K_BKSP]              > index(baseRingB,1)   
any(RingB)                          + outs(keyRingB)        > context beep
                                    + outs(keyRingB)        > U+0325      
U+0325                              + outs(keyRingB)        > context beep

c comma below U+0326, requires keyDiac
any(baseCommaB)     outs(keyDiac)   + outs(keyCommaB)       > index(CommaB,1)         
any(CommaB)                         + [K_BKSP]              > index(baseCommaB,1)   

c cedilla U+0327
any(baseCedilla)                    + outs(keyCedilla)      > index(Cedilla,1)      
any(Cedilla)                        + [K_BKSP]              > index(baseCedilla,1)   
any(Cedilla)                        + outs(keyCedilla)      > context beep
                                    + outs(keyCedilla)      > U+0327
U+0327                              + outs(keyCedilla)      > context beep
c cedilla combining, see store(CombMark)

c ogonek U+0328, requires keyDiac
any(baseOgonek)     outs(keyDiac)   + outs(keyOgonek)       > index(Ogonek,1)      
any(Ogonek)                         + [K_BKSP]              > index(baseOgonek,1)   

                                                                                    

c bridge below
c no composites
                                    + outs(keyBridgeB)      > U+032A      
U+032A                              + outs(keyBridgeB)      > context beep

c caron below
c no composites
                                    + outs(keyCaronB)       > U+032C      
U+032C                              + outs(keyCaronB)       > context beep

c circumflex below
any(baseCircB)                      + outs(keyCircB)        > index(CircB,1)         
any(CircB)                          + [K_BKSP]              > index(baseCircB,1)   
any(CircB)                          + outs(keyCircB)        > context beep
                                    + outs(keyCircB)        > U+032D      
U+032D                              + outs(keyCircB)        > context beep

c breve below
any(baseBreveB)                     + outs(keyBreveB)       > index(BreveB,1)         
any(BreveB)                         + [K_BKSP]              > index(baseBreveB,1)   
any(BreveB)                         + outs(keyBreveB)       > context beep
                                    + outs(keyBreveB)       > U+032E     
U+032E                              + outs(keyBreveB)       > context beep

c inverted breve below
c no composites
                                    + outs(keyInvBreveB)    > U+032F      
U+032F                              + outs(keyInvBreveB)    > context beep

c tilde below (visible trigger)
any(baseTildeB)                     + outs(keyTildeB)       > index(TildeB,1)        
any(TildeB)                         + [K_BKSP]              > index(baseTildeB,1)   
any(TildeB)                         + outs(keyTildeB)       > index(baseTildeB,1)   outs(keyTildeB)
any(baseTildeB) outs(keyTildeB)     + outs(keyTildeB)       > index(TildeB,1)       outs(keyTildeB)
any(baseComTildeB)                  + outs(keyTildeB)       > context   U+0330      
U+0330                              + outs(keyTildeB)       >                       outs(keyTildeB)
any(baseComTildeB) outs(keyTildeB)  + outs(keyTildeB)       > context(1) U+0330     outs(keyTildeB)

c macron below
c composites are actually underlined math symbols
any(baseMacronB)                    + outs(keyMacronB)      > index(MacronB,1)      
any(MacronB)                        + [K_BKSP]              > index(baseMacronB,1)   
any(MacronB)                        + outs(keyMacronB)      > context beep
                                    + outs(keyMacronB)      > U+0331      
U+0331                              + outs(keyMacronB)      > context beep

c tilde overlay
any(baseTildeO)                     + outs(keyTildeO)       > index(TildeO,1)       
any(baseTildeO)     outs(keyDiac)   + outs(keyTildeO)       > index(TildeO,1)       
any(TildeO)                         + [K_BKSP]              > index(baseTildeO,1)   
any(TildeO)                         + outs(keyTildeO)       > context beep
c tilde overlay combining, see store(CombMark) (not available except with keyDiac)

c stroke overlay
any(baseStroke)                     + outs(keyStroke)       > index(Stroke,1)       
any(baseStroke)     outs(keyDiac)   + outs(keyStroke)       > index(Stroke,1)       
any(Stroke)                         + [K_BKSP]              > index(baseStroke,1)   
any(Stroke)                         + outs(keyStroke)       > context beep
c stroke combining, see store(CombMark) (not available except with keyDiac)

c solidus (slash) overlay
any(baseSlash)                      + outs(keySlash)        > index(Slash,1)        
any(baseSlash)      outs(keyDiac)   + outs(keySlash)        > index(Slash,1)        
any(Slash)                          + [K_BKSP]              > index(baseSlash,1)   
any(Slash)                          + outs(keySlash)        > context beep
c slash combining, see store(CombMark) (not available except with keyDiac)

c inverted bridge below
c no composites
                                    + outs(keyInvBridgeB)   > U+033A      
U+033A                              + outs(keyInvBridgeB)   > context beep

c square below
c no composites
U+033A                              + outs(keyBridgeB)      > U+033B      
U+032A                              + outs(keyInvBridgeB)   > U+033B      
U+033B                              + outs(keyBridgeB)      > context beep
U+033B                              + outs(keyInvBridgeB)   > context beep

c bridge above
c no composites
                                    + outs(keyBridge)       > U+0346      
U+0346                              + outs(keyBridge)       > context beep

c double breve and double macron, see store(CombMark) (not available except with keyDiac) 
c double breve below and double macron below, see store(baseLowered) 
c double inverted breve combining, see store(CombMark) (not available except with keyDiac)




c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c trigger characters (for non-diacritics), positioned after the letter to be modified

c If the trigger key is visible, follow this pattern:
c any(baseRaised)                 +  outs(keyRaised)      > index(Raised,1)
c any(Raised)                     +  outs(keyRaised)      > index(baseRaised,1)  outs(keyRaised) 
c any(baseRaised) outs(keyRaised) +  outs(keyRaised)      > index(Raised,1)      outs(keyRaised) 
c
c If the trigger key is invisible, follow this pattern:
c any(baseRaised)                 +  outs(keyRaised)      > index(Raised,1)
c any(Raised)                     +  outs(keyRaised)      > context

c raised characters (superscripts)
any(baseRaised)                 +  outs(keyRaised)      > index(Raised,1)
any(Raised)                     +  outs(keyRaised)      > context beep

c raised characters with underline (combining macron below)
c This provides an alternate key sequence in which the macron below is applied before raising the character.
any(baseRaisedUL) U+0331        +  outs(keyRaised)      > index(RaisedUL,1)
any(RaisedUL)                   +  outs(keyRaised)      > context beep

c lowered characters (subscripts)
any(baseLowered)                +  outs(keyLowered)     > index(Lowered,1)
any(Lowered)                    +  outs(keyLowered)     > context beep

c make character larger
any(baseLarger)                 + outs(keyLarger)       > index(Larger,1)
any(Larger)                     + outs(keyLarger)       > context beep

c make character smaller
any(baseSmaller)                + outs(keySmaller)      > index(Smaller,1)
any(Smaller)                    + outs(keySmaller)      > context beep

c reversed characters
any(baseRev)                    + outs(keyRev)          > index(Rev,1)
any(Rev)                        + outs(keyRev)          > index(baseRev,1)
c here, it _does_ make sense to allow user to reverse a character as much as they want, rather than just discarding the 2nd keypress

c turned characters
any(baseTurn)                   + outs(keyTurn)         > index(Turn,1)
any(Turn)                       + outs(keyTurn)         > index(baseTurn,1)
c ditto, don't discard the 2nd keypress, but turn it again.  This is especially important for the arrows, which only turn
c 1/4 or 1/8 turn at a time.

c phonetic characters based on Greek
any(basePhGrk)                  + outs(keyPhGrk)        > index(PhGrk,1)
any(PhGrk)                      + outs(keyPhGrk)        > context beep

c miscellaneous IPA  
any(baseIPA)                    +  outs(keyIPA)         > index(IPA,1)
any(IPA)                        +  outs(keyIPA)         > context beep

c palatal curls
any(basePalMisc)                +  outs(keyPalMisc)     > index(PalMisc,1)
any(PalMisc)                    +  outs(keyPalMisc)     > context beep

c clicks
any(baseClick)                  + outs(keyClick)        > index(Click,1)
any(Click)                      + outs(keyClick)        > context beep

c currency symbols                                             
any(baseCurr)                   + outs(keyCurr)         > index(Curr,1)
any(Curr)                       + outs(keyCurr)         > index(baseCurr,1) outs(keyCurr)
any(baseCurr) outs(keyCurr)     + outs(keyCurr)         > index(Curr,1) outs(keyCurr)

c mathematical symbols
any(baseMath)                   + outs(keyMath)         > index(Math,1)
any(Math)                       + outs(keyMath)         > index(baseMath,1) outs(keyMath)
any(baseMath) outs(keyMath)     + outs(keyMath)         > index(Math,1) outs(keyMath)
c The ones that plausibly involve underlining can also be done with macronB
c The ones that plausibly involve a solidus can also be done with keySlash

c saltillo
c PATCH AREA saltillo (Unicode; see below for ANSI)
c Use the next line if you type saltillos more often than straight apostrophes.  Otherwise, comment it out.
c WARNING: If you use this line, and you also use apostrophe as the trigger key for acute accent,
c you should also change the definition of the store nrmlRsltAcute near the beginning of this file.
c + "'" > outs(saltillo)
c If you use the above line, then you probably also want to use one or both of the next two lines, 
c to make it easy to type a straight quote:
c outs(saltillo)    + "'"   > "'"           c convert saltillo to apostrophe by typing a second apostrophe
c outs(saltillo)  + [K_BKSP]  > "'"               c convert saltillo back to apostrophe
c In either case, you probably want to keep the following line always:
"'" + "'"   > context "'"       c allow a line of straight apostrophes    

c glottal stops and question marks
c (Raised versions of these are handled with the "raised" store.)
c PATCH AREA glottal stop
c Use the next line if you type glottals more often than question marks.  Otherwise, comment it out.
c + '?' > U+0294
c If you use the above line, then you probably also want to use one or both of the next two lines, 
c so you can type a real question mark too:
c U+0294    + '?'   > '?'           c convert glottal stop to question mark by typing a second question mark
c U+0294    + [K_BKSP]    > '?'           c convert glottal stop back to question mark
c In either case, you probably want to keep the following line always:
'?' + '?'   > context '?'       c allow line of question marks

c Quotes
c (This code is commented out because we're now handling it with the other DirMod code below.)
c any(Quote)  + outs(keyLeft)     > index(LQuote,1)
c any(Quote)  + outs(keyRight)    > index(RQuote,1)
c any(Quote)  + outs(keyUp)       > index(SQuote,1) 
c any(Quote)  + outs(keyDown)     > index(DQuote,1) 
c

c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c directional modifiers and arrows
c These work differently than other trigger keys. The way the stores are defined,
c multiple presses of the trigger key produce the same effect, so there is no need
c for code here that processes a second trigger key press.

c single base character (tacks, quotes, etc.)
any(baseDirMod)                 +  outs(keyLeft)     > index(Left,1)
any(Right)                      +  outs(keyLeft)     > index(Left,1)
any(Up)                         +  outs(keyLeft)     > index(Left,1)
any(Down)                       +  outs(keyLeft)     > index(Left,1)
any(Left)                       +  outs(keyRight)    > index(Right,1)
any(baseDirMod)                 +  outs(keyRight)    > index(Right,1)
any(Up)                         +  outs(keyRight)    > index(Right,1)
any(Down)                       +  outs(keyRight)    > index(Right,1)
any(Left)                       +  outs(keyUp)       > index(Up,1)
any(Right)                      +  outs(keyUp)       > index(Up,1)
any(baseDirMod)                 +  outs(keyUp)       > index(Up,1)
any(Down)                       +  outs(keyUp)       > index(Up,1)
any(Left)                       +  outs(keyDown)     > index(Down,1)
any(Right)                      +  outs(keyDown)     > index(Down,1)
any(Up)                         +  outs(keyDown)     > index(Down,1)
any(baseDirMod)                 +  outs(keyDown)     > index(Down,1)

c arrows and other graphic elements
'|^'            + any(DirMod)  > index(Arrow,3)
'||^'           + any(DirMod)  > index(ArrowDbl,4)
'^|^'           + any(DirMod)  > index(ArrowBidi,4)
'^||^'          + any(DirMod)  > index(ArrowBidiDbl,5)
'#'             + any(DirMod)  > index(CropMark,2)

c rotated arrows
any(baseRotate) + outs(keyTurn)      > index(Rotate,1)

c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Digraphs, ligatures, and other multi-character combinations that don't automatically collapse to one character.
c (I wish there was some way to generalize this with stores, but I don't think there is, since the input
c needs to be a sequence of characters, and stores can only handle one character at a time.)
c
c U+00A7 SECTION SIGN
'SS'                    + outs(keyLig) > U+00A7 
U+00A7                  + outs(keyLig) > 'SS' outs(keyLig)
'SS' outs(keyLig)       + outs(keyLig) > U+00A7 outs(keyLig)
c U+00A9 COPYRIGHT SIGN
'(c)'                   + outs(keyLig) > U+00A9
U+00A9                  + outs(keyLig) > '(c)' outs(keyLig)
'(c)' outs(keyLig)      + outs(keyLig) > U+00A9 outs(keyLig)
c U+00AB LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
'<<'                    + outs(keyLig) > U+00AB
U+00AB                  + outs(keyLig) > '<<' outs(keyLig)
'<<' outs(keyLig)       + outs(keyLig) > U+00AB outs(keyLig)
c U+00AE REGISTERED SIGN
'(r)'                   + outs(keyLig) > U+00AE
U+00AE                  + outs(keyLig) > '(r)' outs(keyLig)
'(r)' outs(keyLig)      + outs(keyLig) > U+00AE outs(keyLig)
c U+00B6 PILCROW SIGN (paragraph mark)
'PP'                    + outs(keyLig) > U+00B6 
U+00B6                  + outs(keyLig) > 'PP' outs(keyLig)
'PP' outs(keyLig)       + outs(keyLig) > U+00B6 outs(keyLig)
c U+00BB RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
'>>'                    + outs(keyLig) > U+00BB
U+00BB                  + outs(keyLig) > '>>' outs(keyLig)
'>>' outs(keyLig)       + outs(keyLig) > U+00BB outs(keyLig)
c U+00C6 LATIN CAPITAL LETTER AE
'AE'                    + outs(keyLig) > U+00C6
U+00C6                  + outs(keyLig) > 'AE' outs(keyLig)
'AE' outs(keyLig)       + outs(keyLig) > U+00C6 outs(keyLig)
c U+00DE LATIN CAPITAL LETTER THORN
'Th'                    + outs(keyLig) > U+00DE
U+00DE                  + outs(keyLig) > 'Th' outs(keyLig)
'Th' outs(keyLig)       + outs(keyLig) > U+00DE outs(keyLig)
c U+00DF LATIN SMALL LETTER SHARP S (Eszett)
'ss'                    + outs(keyLig) > U+00DF
U+00DF                  + outs(keyLig) > 'ss' outs(keyLig)
'ss' outs(keyLig)       + outs(keyLig) > U+00DF outs(keyLig)
c U+00E6 LATIN SMALL LETTER AE
'ae'                    + outs(keyLig) > U+00E6
U+00E6                  + outs(keyLig) > 'ae' outs(keyLig)  
'ae' outs(keyLig)       + outs(keyLig) > U+00E6 outs(keyLig)
c U+00FE LATIN SMALL LETTER THORN
'th'                    + outs(keyLig) > U+00FE
U+00FE                  + outs(keyLig) > 'th' outs(keyLig)
'th' outs(keyLig)       + outs(keyLig) > U+00FE outs(keyLig)

c U+0132 LATIN CAPITAL LIGATURE IJ
'IJ'                    + outs(keyLig) > U+0132
U+0132                  + outs(keyLig) > 'IJ' outs(keyLig)
'IJ' outs(keyLig)       + outs(keyLig) > U+0132 outs(keyLig)
c U+0133 LATIN SMALL LIGATURE IJ
'ij'                    + outs(keyLig) > U+0133
U+0133                  + outs(keyLig) > 'ij' outs(keyLig)
'ij' outs(keyLig)       + outs(keyLig) > U+0133 outs(keyLig)
c U+013F LATIN CAPITAL LETTER L WITH MIDDLE DOT
'L' U+00B7              + outs(keyLig) > U+013F
U+013F                  + outs(keyLig) > 'L' U+00B7 outs(keyLig)
'L' U+00B7 outs(keyLig) + outs(keyLig) > U+013F outs(keyLig)
c U+0140 LATIN SMALL LETTER L WITH MIDDLE DOT
'l' U+00B7              + outs(keyLig) > U+0140
U+0140                  + outs(keyLig) > 'l' U+00B7 outs(keyLig)
'l' U+00B7 outs(keyLig) + outs(keyLig) > U+0140 outs(keyLig)
c U+0152 LATIN CAPITAL LIGATURE OE
'OE'                    + outs(keyLig) > U+0152
U+0152                  + outs(keyLig) > 'OE' outs(keyLig)
'OE' outs(keyLig)       + outs(keyLig) > U+0152 outs(keyLig)
c U+0153 LATIN SMALL LIGATURE OE
'oe'                    + outs(keyLig) > U+0153 
U+0153                  + outs(keyLig) > 'oe' outs(keyLig)
'oe' outs(keyLig)       + outs(keyLig) > U+0153 outs(keyLig)  
c U+0195 LATIN SMALL LETTER HV
'hv'                    + outs(keyLig) > U+0195
U+0195                  + outs(keyLig) > 'hv' outs(keyLig)
'hv' outs(keyLig)       + outs(keyLig) > U+0195 outs(keyLig)  
c U+019B LATIN SMALL LETTER LAMBDA WITH STROKE
'tl'                    + outs(keyLig) > U+019B
U+019B                  + outs(keyLig) > 'tl' outs(keyLig)
'tl' outs(keyLig)       + outs(keyLig) > U+019B outs(keyLig)
c U+01A2 LATIN CAPITAL LETTER OI
'Oi'                    + outs(keyLig) > U+01A2
U+01A2                  + outs(keyLig) > 'Oi' outs(keyLig)
'Oi' outs(keyLig)       + outs(keyLig) > U+01A2 outs(keyLig)  
c U+01A3 LATIN SMALL LETTER OI
'oi'                    + outs(keyLig) > U+01A3
U+01A3                  + outs(keyLig) > 'oi' outs(keyLig)
'oi' outs(keyLig)       + outs(keyLig) > U+01A3 outs(keyLig)  
c U+01F6 LATIN CAPITAL LETTER HWAIR
'Hv'                    + outs(keyLig) > U+01F6
U+01F6                  + outs(keyLig) > 'Hv' outs(keyLig)
'Hv' outs(keyLig)       + outs(keyLig) > U+01F6 outs(keyLig)  
c U+01C4 LATIN CAPITAL LETTER DZ WITH CARON
'D' U+017D              + outs(keyLig) > U+01C4
U+01C4                  + outs(keyLig) > 'D' U+017D outs(keyLig)
'D' U+017D outs(keyLig) + outs(keyLig) > U+01C4 outs(keyLig)
c U+01C5 LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON
'D' U+017E              + outs(keyLig) > U+01C5
U+01C5                  + outs(keyLig) > 'D' U+017E outs(keyLig)
'D' U+017E outs(keyLig) + outs(keyLig) > U+01C5 outs(keyLig)
c U+01C6 LATIN SMALL LETTER DZ WITH CARON
'd' U+017E              + outs(keyLig) > U+01C6
U+01C6                  + outs(keyLig) > 'd' U+017E outs(keyLig)
'd' U+017E outs(keyLig) + outs(keyLig) > U+01C6 outs(keyLig)
c U+01C7 LATIN CAPITAL LETTER LJ
'LJ'                    + outs(keyLig) > U+01C7 
U+01C7                  + outs(keyLig) > 'LJ' outs(keyLig)
'LJ' outs(keyLig)       + outs(keyLig) > U+01C7 outs(keyLig)
c U+01C8 LATIN CAPITAL LETTER L WITH SMALL LETTER J
'Lj'                    + outs(keyLig) > U+01C8 
U+01C8                  + outs(keyLig) > 'Lj' outs(keyLig)
'Lj' outs(keyLig)       + outs(keyLig) > U+01C8 outs(keyLig)
c U+01C9 LATIN SMALL LETTER LJ
'lj'                    + outs(keyLig) > U+01C9 
U+01C9                  + outs(keyLig) > 'lj' outs(keyLig)
'lj' outs(keyLig)       + outs(keyLig) > U+01C9 outs(keyLig)
c U+01CA LATIN CAPITAL LETTER NJ
'NJ'                    + outs(keyLig) > U+01CA 
U+01CA                  + outs(keyLig) > 'NJ' outs(keyLig)
'NJ' outs(keyLig)       + outs(keyLig) > U+01CA outs(keyLig)
c U+01CB LATIN CAPITAL LETTER N WITH SMALL LETTER J
'Nj'                    + outs(keyLig) > U+01CB 
U+01CB                  + outs(keyLig) > 'Nj' outs(keyLig)
'Nj' outs(keyLig)       + outs(keyLig) > U+01CB outs(keyLig)
c U+01CC LATIN SMALL LETTER NJ
'nj'                    + outs(keyLig) > U+01CC 
U+01CC                  + outs(keyLig) > 'nj' outs(keyLig)
'nj' outs(keyLig)       + outs(keyLig) > U+01CC outs(keyLig)
c U+01F1 LATIN CAPITAL LETTER DZ
'DZ'                    + outs(keyLig) > U+01F1 
U+01F1                  + outs(keyLig) > 'DZ' outs(keyLig)
'DZ' outs(keyLig)       + outs(keyLig) > U+01F1 outs(keyLig)
c U+01F2 LATIN CAPITAL LETTER D WITH SMALL LETTER Z
'Dz'                    + outs(keyLig) > U+01F2 
U+01F2                  + outs(keyLig) > 'Dz' outs(keyLig)
'Dz' outs(keyLig)       + outs(keyLig) > U+01F2 outs(keyLig)
c U+01F3 LATIN SMALL LETTER DZ (not implemented, in order to allow U+02A3)
                                      
c U+0222 LATIN CAPITAL LETTER OU
'Ou'                    + outs(keyLig) > U+0222 
U+0222                  + outs(keyLig) > 'Ou' outs(keyLig)
'Ou' outs(keyLig)       + outs(keyLig) > U+0222 outs(keyLig)
c U+0223 LATIN SMALL LETTER OU
'ou'                    + outs(keyLig) > U+0223 
U+0223                  + outs(keyLig) > 'ou' outs(keyLig)
'ou' outs(keyLig)       + outs(keyLig) > U+0223 outs(keyLig)
c U+0238 LATIN SMALL LETTER DB DIGRAPH
'db'                    + outs(keyLig) > U+0238
U+0238                  + outs(keyLig) > 'db' outs(keyLig)
'db' outs(keyLig)       + outs(keyLig) > U+0238 outs(keyLig)   
c U+0239 LATIN SMALL LETTER QP DIGRAPH
'qp'                    + outs(keyLig) > U+0239
U+0239                  + outs(keyLig) > 'qp' outs(keyLig)
'qp' outs(keyLig)       + outs(keyLig) > U+0239 outs(keyLig)   
c U+0267 LATIN SMALL LETTER HENG WITH HOOK
c constructed from hooktop h plus eng
U+0266 U+014B           + outs(keyLig) > U+0267
U+0267                  + outs(keyLig) > U+0266 U+014B outs(keyLig)
U+0266 U+014B outs(keyLig) + outs(keyLig) > U+0267 outs(keyLig)
c U+026E LATIN SMALL LETTER LEZH
'l' U+0292              + outs(keyLig) > U+026E
U+026E                  + outs(keyLig) > 'l' U+0292 outs(keyLig)
'l' U+0292 outs(keyLig) + outs(keyLig) > U+026E outs(keyLig)
c U+0270 LATIN SMALL LETTER TURNED M WITH LONG LEG
c constructed from 'u' plus turned 'h'
'u' U+0265              + outs(keyLig) > U+0270
U+0270                  + outs(keyLig) > 'u' U+0265 outs(keyLig)
'u' U+0265 outs(keyLig) + outs(keyLig) > U+0270 outs(keyLig)
c U+027A LATIN SMALL LETTER TURNED R WITH LONG LEG
'rl'                    + outs(keyLig) > U+027A
U+027A                  + outs(keyLig) > 'rl' outs(keyLig)
'rl' outs(keyLig)       + outs(keyLig) > U+027A outs(keyLig)
c U+02A3 LATIN SMALL LETTER DZ DIGRAPH
'dz'                    + outs(keyLig) > U+02A3
U+02A3                  + outs(keyLig) > 'dz' outs(keyLig)
'dz' outs(keyLig)       + outs(keyLig) > U+02A3 outs(keyLig)
c U+02A4 LATIN SMALL LETTER DEZH DIGRAPH 
'd' U+0292              + outs(keyLig) > U+02A4
U+02A4                  + outs(keyLig) > 'd' U+0292 outs(keyLig)
'd' U+0292 outs(keyLig) + outs(keyLig) > U+02A4 outs(keyLig)
c U+02A5 LATIN SMALL LETTER DZ DIGRAPH WITH CURL (also generable by putting a curl on DZ DIGRAPH)
'd' U+0291              + outs(keyLig) > U+02A5
U+02A5                  + outs(keyLig) > 'd' U+0291 outs(keyLig)
'd' U+0291 outs(keyLig) + outs(keyLig) > U+02A5 outs(keyLig)
c U+02A6 LATIN SMALL LETTER TS DIGRAPH
'ts'                    + outs(keyLig) > U+02A6
U+02A6                  + outs(keyLig) > 'ts' outs(keyLig)
'ts' outs(keyLig)       + outs(keyLig) > U+02A6 outs(keyLig)
c U+02A7 LATIN SMALL LETTER TESH DIGRAPH
't' U+0283              + outs(keyLig) > U+02A7
U+02A7                  + outs(keyLig) > 't' U+0283 outs(keyLig)
't' U+0283 outs(keyLig) + outs(keyLig) > U+02A7 outs(keyLig)
c U+02A8 LATIN SMALL LETTER TC DIGRAPH WITH CURL
't' U+0255              + outs(keyLig) > U+02A8
U+02A8                  + outs(keyLig) > 't' U+0255 outs(keyLig)
't' U+0255 outs(keyLig) + outs(keyLig) > U+02A8 outs(keyLig)
c U+02A9 LATIN SMALL LETTER FENG DIGRAPH
'f' U+014B              + outs(keyLig) > U+02A9
U+02A9                  + outs(keyLig) > 'f' U+014B outs(keyLig)
'f' U+014B outs(keyLig) + outs(keyLig) > U+02A9 outs(keyLig)
c U+02AA LATIN SMALL LETTER LS DIGRAPH
'ls'                    + outs(keyLig) > U+02AA
U+02AA                  + outs(keyLig) > 'ls' outs(keyLig)
'ls' outs(keyLig)       + outs(keyLig) > U+02AA outs(keyLig)
c U+02AB LATIN SMALL LETTER LZ DIGRAPH
'lz'                    + outs(keyLig) > U+02AB
U+02AB                  + outs(keyLig) > 'lz' outs(keyLig)
'lz' outs(keyLig)       + outs(keyLig) > U+02AB outs(keyLig)
c U+02E5 MODIFIER LETTER EXTRA-HIGH TONE BAR through U+02E9 MODIFIER LETTER EXTRA-LOW TONE BAR (right-stem)
any(baseToneLetter) '|'                 + outs(keyLig)          > index(ToneLetterR,1)
any(ToneLetterR)                        + any(baseToneLetter)   > context index(ToneLetterR,2)
any(ToneLetterR)                        + outs(keyLig)          > index(baseToneLetter,1) '|' outs(keyLig)
any(baseToneLetter) '|' outs(keyLig)    + outs(keyLig)          > index(ToneLetterR,1) outs(keyLig)
c U+A708 MODIFIER LETTER EXTRA-HIGH DOTTED TONE BAR through U+A70C MODIFIER LETTER EXTRA-LOW DOTTED TONE BAR (right-stem)
any(baseToneLetter) '.|'                + outs(keyLig)          > index(ToneLetterDR,1)
any(ToneLetterDR)                       + any(baseToneLetter)   > context index(ToneLetterDR,2)
any(ToneLetterDR)                       + outs(keyLig)          > index(baseToneLetter,1) '.|' outs(keyLig)
any(baseToneLetter) '.|' outs(keyLig)   + outs(keyLig)          > index(ToneLetterDR,1) outs(keyLig)
c U+A712 MODIFIER LETTER EXTRA-HIGH LEFT-STEM TONE BAR through U+A716 MODIFIER LETTER EXTRA-LOW LEFT-STEM TONE BAR
'|' any(baseToneLetter)                 + outs(keyLig)          > index(ToneLetterL,2)
any(ToneLetterL)                        + any(baseToneLetter)   > context index(ToneLetterL,2)
any(ToneLetterL)                        + outs(keyLig)          > '|' index(baseToneLetter,1) outs(keyLig)
'|' any(baseToneLetter) outs(keyLig)    + outs(keyLig)          > index(ToneLetterL,2) outs(keyLig)         
c U+A70D MODIFIER LETTER EXTRA-HIGH DOTTED LEFT-STEM TONE BAR through U+A711 MODIFIER LETTER EXTRA-LOW DOTTED LEFT-STEM TONE BAR
'|.' any(baseToneLetter)                + outs(keyLig)          > index(ToneLetterDL,3)
any(ToneLetterDL)                       + any(baseToneLetter)   > context index(ToneLetterDL,2)
any(ToneLetterDL)                       + outs(keyLig)          > '|.' index(baseToneLetter,1) outs(keyLig)
'|.' any(baseToneLetter) outs(keyLig)   + outs(keyLig)          > index(ToneLetterDL,3) outs(keyLig)         


c U+1D6B LATIN SMALL LETTER UE
c can't find an upper case version
'ue'                    + outs(keyLig) > U+1D6B 
U+1D6B                  + outs(keyLig) > 'ue' outs(keyLig)
'ue' outs(keyLig)       + outs(keyLig) > U+1D6B outs(keyLig)

c U+2010 through U+2015 dashes: see below 
c
c U+2016 DOUBLE VERTICAL LINE
'||'                    + outs(keyLig) > U+2016
U+2016                  + outs(keyLig) > '||' outs(keyLig)
'||' outs(keyLig)       + outs(keyLig) > U+2016 outs(keyLig)
c U+2017 DOUBLE LOW LINE
'__'                    + outs(keyLig) > U+2017
U+2017                  + outs(keyLig) > '__' outs(keyLig)
'__' outs(keyLig)       + outs(keyLig) > U+2017 outs(keyLig)
c U+2020 DAGGER
'tt'                    + outs(keyLig) > U+2020 
U+2020                  + outs(keyLig) > 'tt' outs(keyLig)
'tt' outs(keyLig)       + outs(keyLig) > U+2020 outs(keyLig)
c U+2021 DOUBLE DAGGER
'TT'                    + outs(keyLig) > U+2021 
U+2021                  + outs(keyLig) > 'TT' outs(keyLig)
'TT' outs(keyLig)       + outs(keyLig) > U+2021 outs(keyLig)
c
c U+2026 ELLIPSIS: see below
c
c U+2030 PER MILLE SIGN
'%0'                    + outs(keyLig) > U+2030 
U+2030                  + outs(keyLig) > '%0' outs(keyLig)
'%0' outs(keyLig)       + outs(keyLig) > U+2030 outs(keyLig)
c U+2031 PER TEN THOUSAND SIGN
'%00'                   + outs(keyLig) > U+2031 
U+2031                  + outs(keyLig) > '%00' outs(keyLig)
'%00' outs(keyLig)      + outs(keyLig) > U+2031 outs(keyLig)
c U+2039 SINGLE LEFT-POINTING ANGLE QUOTATION MARK
'<'                     + outs(keyLig) > U+2039 
U+2039                  + outs(keyLig) > '<' outs(keyLig)
'<' outs(keyLig)        + outs(keyLig) > U+2039 outs(keyLig)
c U+203A SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
'>'                     + outs(keyLig) > U+203A 
U+203A                  + outs(keyLig) > '>' outs(keyLig)
'>' outs(keyLig)        + outs(keyLig) > U+203A outs(keyLig)
c U+203C DOUBLE EXCLAMATION MARK
'!!'                    + outs(keyLig) > U+203C 
U+203C                  + outs(keyLig) > '!!' outs(keyLig)
'!!' outs(keyLig)       + outs(keyLig) > U+203C outs(keyLig)
c U+203D INTERROBANG
U+2048                  + outs(keyLig) > U+203D 
U+2049                  + outs(keyLig) > U+203D 
c U+2047 DOUBLE QUESTION MARK
'??'                    + outs(keyLig) > U+2047 
U+2047                  + outs(keyLig) > '??' outs(keyLig)
'??' outs(keyLig)       + outs(keyLig) > U+2047 outs(keyLig)
c U+2048 QUESTION EXCLAMATION MARK
'?!'                    + outs(keyLig) > U+2048 
  c no further options because of U+203D INTEROBANG
c U+2049 EXCLAMATION QUESTION MARK
'!?'                    + outs(keyLig) > U+2049 
  c no further options because of U+203D INTEROBANG

c U+2100 ACCOUNT OF
'a/c'                   + outs(keyLig) > U+2100 
U+2100                  + outs(keyLig) > 'a/c' outs(keyLig)
'a/c' outs(keyLig)      + outs(keyLig) > U+2100 outs(keyLig)
c U+2101 ADDRESSED TO THE SUBJECT
'a/s'                   + outs(keyLig) > U+2101 
U+2101                  + outs(keyLig) > 'a/s' outs(keyLig)
'a/s' outs(keyLig)      + outs(keyLig) > U+2101 outs(keyLig)
c U+2103 DEGREE CELSIUS
U+00B0 'C'              + outs(keyLig) > U+2103 
U+2103                  + outs(keyLig) > U+00B0 'C' outs(keyLig)
U+00B0 'C' outs(keyLig) + outs(keyLig) > U+2103 outs(keyLig)
c U+2105 CARE OF
'c/o'                   + outs(keyLig) > U+2105 
U+2105                  + outs(keyLig) > 'c/o' outs(keyLig)
'c/o' outs(keyLig)      + outs(keyLig) > U+2105 outs(keyLig)
c U+2106 CADA UNA
'c/u'                   + outs(keyLig) > U+2106 
U+2106                  + outs(keyLig) > 'c/u' outs(keyLig)
'c/u' outs(keyLig)      + outs(keyLig) > U+2106 outs(keyLig)
c U+2109 DEGREE FAHRENHEIT
U+00B0 'F'              + outs(keyLig) > U+2109 
U+2109                  + outs(keyLig) > U+00B0 'F' outs(keyLig)
U+00B0 'F' outs(keyLig) + outs(keyLig) > U+2109 outs(keyLig)
c U+2114 L B BAR SYMBOL
'lb'                    + outs(keyLig) > U+2114 
U+2114                  + outs(keyLig) > 'lb' outs(keyLig)
'lb' outs(keyLig)       + outs(keyLig) > U+2114 outs(keyLig)
c U+2116 NUMERO SIGN
'No'                    + outs(keyLig) > U+2116 
U+2116                  + outs(keyLig) > 'No' outs(keyLig)
'No' outs(keyLig)       + outs(keyLig) > U+2116 outs(keyLig)
c U+2117 SOUND RECORDING COPYRIGHT
'(p)'                    + outs(keyLig) > U+2117 
U+2117                  + outs(keyLig) > '(p)' outs(keyLig)
'(p)' outs(keyLig)       + outs(keyLig) > U+2117 outs(keyLig)
c U+211E PRESCRIPTION TAKE
'Rx'                    + outs(keyLig) > U+211E 
U+211E                  + outs(keyLig) > 'Rx' outs(keyLig)
'Rx' outs(keyLig)       + outs(keyLig) > U+211E outs(keyLig)
c U+2120 SERVICE MARK
'SM'                    + outs(keyLig) > U+2120 
U+2120                  + outs(keyLig) > 'SM' outs(keyLig)
'SM' outs(keyLig)       + outs(keyLig) > U+2120 outs(keyLig)
c U+2121 TELEPHONE SIGN
'TEL'                   + outs(keyLig) > U+2121 
U+2121                  + outs(keyLig) > 'TEL' outs(keyLig)
'TEL' outs(keyLig)      + outs(keyLig) > U+2121 outs(keyLig)
c U+2122 TRADEMARK SIGN
'TM'                    + outs(keyLig) > U+2122 
U+2122                  + outs(keyLig) > 'TM' outs(keyLig)
'TM' outs(keyLig)       + outs(keyLig) > U+2122 outs(keyLig)
c U+2125 OUNCE SIGN
'oz'                    + outs(keyLig) > U+2125
U+2125                  + outs(keyLig) > 'oz' outs(keyLig)
'oz' outs(keyLig)       + outs(keyLig) > U+2125 outs(keyLig)
c U+212A KELVIN SIGN
'K'                     + outs(keyLig) > U+212A
U+212A                  + outs(keyLig) > 'K' outs(keyLig)
'K' outs(keyLig)        + outs(keyLig) > U+212A outs(keyLig)
c U+213B FACSIMILE SIGN
'FAX'                   + outs(keyLig) > U+213B 
U+213B                  + outs(keyLig) > 'FAX' outs(keyLig)
'FAX' outs(keyLig)      + outs(keyLig) > U+213B outs(keyLig)

c dashes and ellipses
c Treated all together in the same place here, because some of them have special characteristics
c in common with each other.
c
c U+002D HYPHEN MINUS
c   (keyboard it normally)
c U+00AD SOFT HYPHEN
c   NB: Word uses U+001F (SI) for optional hyphen, not U+00AD
'-s'                    + outs(keyLig) > U+00AD        
U+00AD                  + outs(keyLig) > '-s' outs(keyLig)
'-s' outs(keyLig)       + outs(keyLig) > U+00AD outs(keyLig)
c U+2010 HYPHEN
'-h'                    + outs(keyLig) > U+2010
U+2010                  + outs(keyLig) > '-h' outs(keyLig)
'-h' outs(keyLig)       + outs(keyLig) > U+2010 outs(keyLig)
c U+2011 NON-BREAKING HYPHEN
c   NB: Word uses U+001E (RS) for no-break hyphen, not U+2011
'-nb'                   + outs(keyLig) > U+2011        
U+2011                  + outs(keyLig) > '-nb' outs(keyLig)
'-nb' outs(keyLig)      + outs(keyLig) > U+2011 outs(keyLig)
c U+2012 FIGURE DASH
'-f'                    + outs(keyLig) > U+2012
U+2012                  + outs(keyLig) > '-f' outs(keyLig)
'-f' outs(keyLig)       + outs(keyLig) > U+2012 outs(keyLig)
c U+2013 EN DASH
c PATCH AREA en dash: optionally comment out the first line if you use two equals more often than en dash
'='     + '='           > U+2013        c en dash
'=='    + outs(keyLig)  > U+2013        c convert two equals to en dash
U+2013  + [K_BKSP]      > '=='          c convert en dash to two equals
U+2013  + '='           > '=='          c convert en dash to two equals (typically for starting a line of equals)
'=='    + '='           > context '='   c continue line of equals
c unambiguous and systematic way of keying en dash
'-n'                    + outs(keyLig) > U+2013        
U+2013                  + outs(keyLig) > '-n' outs(keyLig)
'-n' outs(keyLig)       + outs(keyLig) > U+2013 outs(keyLig)
c U+2014 EM DASH
c PATCH AREA em dash: optionally comment out the first line if you use two hyphens more often than em dash 
'-'     + '-'           > U+2014        c em dash
'--'    + outs(keyLig)  > U+2014        c convert two hyphens to em dash
U+2014  + [K_BKSP]      > '--'          c convert em dash to two hyphens
U+2014  + '-'           > '--'          c convert em dash to two hyphens (typically for starting a line of hyphens)
'--'    + '-'           > context '-'   c continue line of hyphens
c Special cases: don't convert -- to em dash in HTML comment
'<!-'   + '-'           > '<!--'        
U+2014  + '>'           > '-->'         
c unambiguous and systematic way of keying em dash
'-m'                    + outs(keyLig) > U+2014
U+2014                  + outs(keyLig) > '-m' outs(keyLig)
'-m' outs(keyLig)       + outs(keyLig) > U+2014 outs(keyLig)
c U+2015 QUOTATION DASH
'-q'                    + outs(keyLig) > U+2015
U+2015                  + outs(keyLig) > '-q' outs(keyLig)
'-q' outs(keyLig)       + outs(keyLig) > U+2015 outs(keyLig)

c U+2026 ELLIPSIS
c PATCH AREA ellipsis: optionally comment out the first line if you use three periods more often than ellipsis.
'..'    + '.'           > U+2026        c ellipsis
'...'   + outs(keyLig)  > U+2026        c convert three periods to ellipsis
U+2026  + [K_BKSP]      > '...'         c convert ellipsis to three periods
U+2026 '.' + '.'        > '.....'       c start a line of periods 
'...'   + '.'           > context '.'   c continue line of periods
c


c ========================================================================================================
c FRACTIONS

c ASSUMES:
c The store FracSlash (defined above) contains the character that should be used for the slash in fractions,
c typically either the ordinary slash or U+2044 FRACTION SLASH

c This code only handles fractions involving ordinary unsigned integers, not formulas, as numerator and denominator.
c If you need anything fancier than that, you should use an equation editor.

c Numerator
c for multi-digit numerators: once superscripting is started, continue it 
any(RsdDigit)           + any(baseDigit)    > context index(RsdDigit,2)                     

c Operator
c When encountering a typed slash, it either gets translated to whatever we're using to represent the slash in fractions,
c or in a special case, to a composite when the numerator is exactly 1.
any(RsdDigit) any(RsdDigit) + '/'       > context outs(FracSlash)   c with more than one digit in numerator: whatever slash we're using 
U+00B9                      + '/'       > U+215F                    c special case: composite FRACTION NUMERATOR ONE
U+215F                      + [K_BKSP]  > U+00B9                    c undo FRACTION NUMERATOR ONE
any(RsdDigit)               + '/'       > context outs(FracSlash)   c default: whatever slash we're using

c Denominator
c
c Switch to subscript after 2 superscript digits and slash. This also blocks composite fractions for 2-digit numerators.
any(RsdDigit) any(RsdDigit) any(FracSlash) + any(baseDigit) > context index(LowDigit,4)     
c                                                                                            
c There are composite fractions for certain combinations of single-digit numerators and single-digit denominators
c If a second digit is found for the denominator, then the composite must be unbundled again.
c (Those involving a numerator 1 are commented out because I think they won't be needed, but I'm keeping them just in case.)
c
c U+00B9 any(FracSlash)   + '2' > U+00BD c 1/2
       U+215F           + '2'               > U+00BD c 1/2 starting from FRACTION NUMERATOR ONE 
       U+00BD           + [K_BKSP]          > U+215F
       U+00BD           + any(baseDigit)    > U+00B9 outs(FracSlash) U+2082 index(LowDigit,2)
c
c U+00B9 any(FracSlash)   + '3' > U+2153 c 1/3
       U+215F           + '3'               > U+2153 c 1/3 starting from FRACTION NUMERATOR ONE 
       U+2153           + [K_BKSP]          > U+215F
       U+2153           + any(baseDigit)    > U+00B9 outs(FracSlash) U+2083 index(LowDigit,2)
c
U+00B2 any(FracSlash)   + '3'               > U+2154 c 2/3
       U+2154           + [K_BKSP]          > U+00B2 outs(FracSlash)
       U+2154           + any(baseDigit)    > U+00B2 outs(FracSlash) U+2083 index(LowDigit,2)
c
c U+00B9 any(FracSlash)   + '4' > U+00BC c 1/4
       U+215F           + '4'               > U+00BC c 1/4 starting from FRACTION NUMERATOR ONE 
       U+00BC           + [K_BKSP]          > U+215F
       U+00BC           + any(baseDigit)    > U+00B9 outs(FracSlash) U+2084 index(LowDigit,2)
c
U+00B3 any(FracSlash)   + '4'               > U+00BE c 3/4
       U+00BE           + [K_BKSP]          > U+00B3 outs(FracSlash)
       U+00BE           + any(baseDigit)    > U+00B3 outs(FracSlash) U+2084 index(LowDigit,2)
c
c U+00B9 any(FracSlash)   + '5' > U+2155 c 1/5
       U+215F           + '5'               > U+2155 c 1/5 starting from FRACTION NUMERATOR ONE 
       U+2155           + [K_BKSP]          > U+215F
       U+2155           + any(baseDigit)    > U+00B9 outs(FracSlash) U+2085 index(LowDigit,2)
c
U+00B2 any(FracSlash)   + '5'               > U+2156 c 2/5
       U+2156           + [K_BKSP]          > U+00B2 outs(FracSlash)
       U+2156           + any(baseDigit)    > U+00B2 outs(FracSlash) U+2085 index(LowDigit,2)
c
U+00B3 any(FracSlash)   + '5'               > U+2157 c 3/5
       U+2157           + [K_BKSP]          > U+00B3 outs(FracSlash)
       U+2157           + any(baseDigit)    > U+00B3 outs(FracSlash) U+2085 index(LowDigit,2)
c
U+2074 any(FracSlash)   + '5'               > U+2158 c 4/5
       U+2158           + [K_BKSP]          > U+2074 outs(FracSlash)
       U+2158           + any(baseDigit)    > U+2074 outs(FracSlash) U+2085 index(LowDigit,2)
c
c U+00B9 any(FracSlash)   + '6' > U+2159 c 1/6
       U+215F           + '6'               > U+2159 c 1/6 starting from FRACTION NUMERATOR ONE 
       U+2159           + [K_BKSP]          > U+215F
       U+2159           + any(baseDigit)    > U+00B9 outs(FracSlash) U+2086 index(LowDigit,2)
c
U+2075 any(FracSlash)   + '6'               > U+215A c 5/6
       U+215A           + [K_BKSP]          > U+2075 outs(FracSlash)
       U+215A           + any(baseDigit)    > U+2075 outs(FracSlash) U+2086 index(LowDigit,2)
c
c U+00B9 any(FracSlash)   + '8' > U+215B c 1/8
       U+215F           + '8'               > U+215B c 1/8 starting from FRACTION NUMERATOR ONE 
       U+215B           + [K_BKSP]          > U+215F
       U+215B           + any(baseDigit)    > U+00B9 outs(FracSlash) U+2088 index(LowDigit,2)
c
U+00B3 any(FracSlash)   + '8'               > U+215C c 3/8
       U+215C           + [K_BKSP]          > U+00B3 outs(FracSlash)
       U+215C           + any(baseDigit)    > U+00B3 outs(FracSlash) U+2088 index(LowDigit,2)
c
U+2075 any(FracSlash)   + '8'               > U+215D c 5/8
       U+215D           + [K_BKSP]          > U+2075 outs(FracSlash)
       U+215D           + any(baseDigit)    > U+2075 outs(FracSlash) U+2088 index(LowDigit,2)
c
U+2077 any(FracSlash)   + '8'               > U+215E c 7/8
       U+215E           + [K_BKSP]          > U+2077 outs(FracSlash)
       U+215E           + any(baseDigit)    > U+2077 outs(FracSlash) U+2088 index(LowDigit,2)
c 
c The default cases, not covered by precomposed fractions
              U+215F            + any(baseDigit)    > U+00B9 outs(FracSlash) index(LowDigit,2)  c unbundle FRACTION NUMERATOR ONE with any other denominator
any(RsdDigit) any(FracSlash)    + any(baseDigit)    > context index(LowDigit,3)                 c switch to sub for rest of denominator
any(LowDigit)                   + any(baseDigit)    > context index(LowDigit,2)         c continue subscripting once started
 

c ========================================================================================================
c Line-breaking and control characters
c My original idea was to support these characters with the same keys as in Word, so that 
c they would be available both inside and outside Word.
c However, Word uses different characters for most of them, so redefining these key sequences to 
c produce the Unicode character would give incorrect results in Word.
c That's why most of these are commented out.
                                                                       
c + [SHIFT K_ENTER]         > U+000A        c LF (line feed)
                                              c Word uses U+000B (VT) for new line
c + [CTRL K_ENTER]          > U+000C        c FF
                                              c Word same, but probably not worth supporting outside Word in most cases
+ [CTRL SHIFT " "]          > outs(nbsp)    c NO-BREAK SPACE
                                              c Word uses the same character for this as Unicode does
c                           > U+200C        c ZERO WIDTH NON-JOINER
                                              c Word same, has expected effect in Latin text; not clear if it's worth providing
c                           > U+200D        c ZERO WIDTH JOINER
                                              c Word same, but doesn't have any effect in Latin text; probably not worth providing

c 
c Pass certain key combinations through unchanged to the application.
c These key combinations have special meanings to applications like Word, and so the application
c needs to see the key combination itself, not the character that it is normally translated to by Keyman.
+ [SHIFT K_ENTER]   > [SHIFT K_ENTER]       c instead of normal translation to U+000A LF
+ [CTRL K_BKSP]     > [CTRL K_BKSP]         c instead of normal translation to U+007F DEL
c NOTE TO ALBERT: This is needed on both my internal and external keyboard, so it has nothing to do with the 
c programming of the external keyboard or its connection to the computer.




c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Main processing (ANSI)
c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

begin ANSI > use(main-A)
group(main-A) using keys  

c The code below duplicates much of the functionality of the Unicode group, but uses the reduced set of characters in the 
c ANSI stores instead of the regular ones, or refers to ANSI characters directly rather than with Unicode numbers.
c For brevity, it omits many of the comments in the code above.

c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Diacritics in apparent isolation

c Technically we don't need to block diacritics after ordinary space in the ANSI keyboard; they are blocked automaticaly
c by virtue of the fact that there are no combining marks to insert.  But, it is helpful to the user to beep,
c to show that they've done something wrong, and to remind them that they need to type no-break space if they
c want to do diacritics in isolation (to maintain consistency with the Unicode keyboard).

any(baseComIllegal)                 + any(InvisibleTrigger)    > context beep
any(baseComIllegal) outs(keyDiac)   + any(InvisibleTrigger)    > context beep
any(baseComIllegal) outs(keyDiac)   + any(VisibleTrigger)      > context index(VisibleTrigger,3)   
c 
nul                 + any(InvisibleTrigger) > beep
nul outs(keyDiac)   + any(InvisibleTrigger) > context beep  
nul outs(keyDiac)   + any(VisibleTrigger)   > context index(VisibleTrigger,3)

c PATCH AREA diacritics in isolation ANSI
c   If you want to be able to use single trigger keys with no-break space to type diacritics in isolation, 
c     comment out the next two lines.
c   If you want to require use of keyDiac, use the next two lines.
c   If you make a change here, make the same change at "PATCH AREA diacritics in isolation" above.
outs(nbsp) + any(InvisibleTrigger)  > context beep
outs(nbsp) + any(VisibleTrigger)    > context index(VisibleTrigger,2)

c Spacing diacritics in Latin-1        
c Leave these two lines unchanged, even if you want to block use of single triggers after no-break space.
c See discussion in Unicode section.
outs(nbsp)                  + any(Trig4SpacingDiac-A)  > index(SpacingDiac-A,2)
outs(nbsp) outs(keyDiac)    + any(Trig4SpacingDiac-A)  > index(SpacingDiac-A,3)


c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c ANSI Diacritics (all composite)

c The general-purpose use of keyDiac with any diacritic trigger key is not supported for ANSI, because
c - there are no combining marks in ANSI to be forced onto base characters that don't normally take them or 
c   to be used to provide two instances of the same diacritic
c - there is no particular point in supporting the redundant use of keyDiac with trigger keys that normally
c   occur alone (this is only supported in a general way for Unicode because that's the easiest way to force the diacritics
c   when they wouldn't otherwise be inserted)
c To put it another way, the uses of keyDiac that are relevant for ANSI Latin-1 are:
c - any that involve composite characters (there may not be any at this point)
c - spacing versions of diacritics, which are handled above

any(baseGrave-A)                    + outs(keyGrave)        > index(Grave-A,1)          c grave composite 
any(Grave-A)                        + [K_BKSP]              > index(baseGrave-A,1)   
any(Grave-A)                        + outs(keyGrave)        > context beep

any(baseAcute-A)                    + outs(keyAcute)        > index(Acute-A,1)          c acute composite 
any(Acute-A)                        + [K_BKSP]              > index(baseAcute-A,1)    
any(Acute-A)                        + outs(keyAcute)        > context beep

any(baseCirc-A)                     + outs(keyCirc)         > index(Circ-A,1)           c circumflex composite 
any(Circ-A)                         + [K_BKSP]              > index(baseCirc-A,1)        
any(Circ-A)                         + outs(keyCirc)         > context beep

any(baseTilde-A)                    + outs(keyTilde)        > index(Tilde-A,1)          c tilde composite 
any(Tilde-A)                        + [K_BKSP]              > index(baseTilde-A,1)
any(Tilde-A)                        + outs(keyTilde)        > index(baseTilde-A,1)    outs(keyTilde)
any(baseTilde-A) outs(keyTilde)     + outs(keyTilde)        > index(Tilde-A,1)        outs(keyTilde)

any(baseDiaer-A)                    + outs(keyDiaer)        > index(Diaer-A,1)          c diaeresis composite 
any(Diaer-A)                        + [K_BKSP]              > index(baseDiaer-A,1)
any(Diaer-A)                        + outs(keyDiaer)        > context beep

any(baseRing-A)                     + outs(keyRing)         > index(Ring-A,1)           c ring above composite 
any(Ring-A)                         + [K_BKSP]              > index(baseRing-A,1)
any(Ring-A)                         + outs(keyRing)         > context beep

any(baseCaron-A)                    + outs(keyCaron)        > index(Caron-A,1)          c caron composite
any(Caron-A)                        + [K_BKSP]              > index(baseCaron-A,1)    
any(Caron-A)                        + outs(keyCaron)        > context beep

any(baseCedilla-A)                  + outs(keyCedilla)      > index(Cedilla-A,1)        c cedilla composite 
any(Cedilla-A)                      + [K_BKSP]              > index(baseCedilla-A,1)    

any(baseMacronB-A)                  + outs(keyMacronB)      > index(MacronB-A,1)        c "macron" below composite, really just plus/minus
any(MacronB-A)                      + [K_BKSP]              > index(baseMacronB-A,1)
any(MacronB-A)                      + outs(keyMacronB)      > context beep

any(baseStroke-A)                   + outs(keyStroke)       > index(Stroke-A,1)         c stroke overlay composite
any(Stroke-A)                       + [K_BKSP]              > index(baseStroke-A,1)    
any(Stroke-A)                       + outs(keyStroke)       > context beep

any(baseSlash-A)                    + outs(keySlash)        > index(Slash-A,1)          c solidus/slash overlay composite
any(Slash-A)                        + [K_BKSP]              > index(baseSlash-A,1)    
any(Slash-A)                        + outs(keySlash)        > context beep


c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c ANSI Non-diacritics 

c raised characters (superscripts)
any(baseRaised-A)               +  outs(keyRaised)      > index(Raised-A,1)
any(Raised-A)                   +  outs(keyRaised)      > context beep

c lowered characters (subscripts)
c There are none in ANSI, but this code is left here in case you want to use keyLowered to generate
c low-9 quotes.
c any(baseLowered-A)              +  outs(keyLowered)     > index(Lowered-A,1)
c any(Lowered-A)                  +  outs(keyLowered)     > context beep

c turned characters
any(baseTurn-A)                 + outs(keyTurn)         > index(Turn-A,1)
any(Turn-A)                     + outs(keyTurn)         > index(baseTurn-A,1)

c phonetic characters based on Greek
any(basePhGrk-A)                + outs(keyPhGrk)        > index(PhGrk-A,1)
any(PhGrk-A)                    + outs(keyPhGrk)        > context beep

c miscellaneous IPA  
any(baseIPA-A)                  + outs(keyIPA)          > index(IPA-A,1)               
any(IPA-A)                      + outs(keyIPA)          > context beep

c saltillo
c PATCH AREA saltillo (ANSI; see above for Unicode)
c Use the next line if you type saltillos more often than apostrophes.  Otherwise, comment it out.
c + "'" > outs(saltillo-A)
c Saltillo can be converted back to apostrophe by following it with keyUp or keyDown; see stores for chevrons and quotes.
c Or, if you prefer, use the next line:
c outs(saltillo-A)    + "'"   > "'"           c convert saltillo to apostrophe by typing a second apostrophe
c In either case, you probably want to keep the following line always:
"'"       + "'"   > context "'"     c line of straight apostrophes    

c Quotes
any(Quote-A)    + outs(keyLeft)     > index(LQuote-A,1)
any(Quote-A)    + outs(keyRight)    > index(RQuote-A,1)
any(Quote-A)    + outs(keyUp)       > index(SQuote-A,1)     c i.e. straight
any(Quote-A)    + outs(keyDown)     > index(DQuote-A,1)     c i.e. low 9
c

c cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Digraphs, ligatures, and other multi-character combinations that don't automatically collapse to one character.
c (I wish there was some way to generalize this with stores.)
c
c U+00A7 SECTION SIGN
'SS'                    + outs(keyLig) > '§'                     
'§'                     + outs(keyLig) > 'SS' outs(keyLig)
'SS' outs(keyLig)       + outs(keyLig) > '§' outs(keyLig)
c U+00A9 COPYRIGHT SIGN
'(c)'                   + outs(keyLig) > '©'
'©'                     + outs(keyLig) > '(c)' outs(keyLig)
'(c)' outs(keyLig)      + outs(keyLig) > '©' outs(keyLig)
c U+00AB LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
'<<'                    + outs(keyLig) > '«'
'«'                     + outs(keyLig) > '<<' outs(keyLig)
'<<' outs(keyLig)       + outs(keyLig) > '«' outs(keyLig)
c U+00AE REGISTERED SIGN
'(r)'                   + outs(keyLig) > '®'
'®'                     + outs(keyLig) > '(r)' outs(keyLig)
'(r)' outs(keyLig)      + outs(keyLig) > '®' outs(keyLig)
c U+00B6 PILCROW SIGN (paragraph mark)
'PP'                    + outs(keyLig) > '¶' 
'¶'                     + outs(keyLig) > 'PP' outs(keyLig)
'PP' outs(keyLig)       + outs(keyLig) > '¶' outs(keyLig)
c U+00BB RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
'>>'                    + outs(keyLig) > '»'
'»'                     + outs(keyLig) > '>>' outs(keyLig)
'>>' outs(keyLig)       + outs(keyLig) > '»' outs(keyLig)
c U+00C6 LATIN CAPITAL LETTER AE
'AE'                    + outs(keyLig) > 'Æ'
'Æ'                     + outs(keyLig) > 'AE' outs(keyLig)
'AE' outs(keyLig)       + outs(keyLig) > 'Æ' outs(keyLig)
c U+00E6 LATIN SMALL LETTER AE
'ae'                    + outs(keyLig) > 'æ'
'æ'                     + outs(keyLig) > 'ae' outs(keyLig)  
'ae' outs(keyLig)       + outs(keyLig) > 'æ' outs(keyLig)    
c U+00DE LATIN CAPITAL LETTER THORN
'Th'                    + outs(keyLig) > 'Þ'
'Þ'                     + outs(keyLig) > 'Th' outs(keyLig)
'Th' outs(keyLig)       + outs(keyLig) > 'Þ' outs(keyLig)
c U+00DF LATIN SMALL LETTER SHARP S (Eszett)
'ss'                    + outs(keyLig) > 'ß'
'ß'                     + outs(keyLig) > 'ss' outs(keyLig)
'ss' outs(keyLig)       + outs(keyLig) > 'ß' outs(keyLig)
c U+00FE LATIN SMALL LETTER THORN
'th'                    + outs(keyLig) > 'þ'
'þ'                     + outs(keyLig) > 'th' outs(keyLig)
'th' outs(keyLig)       + outs(keyLig) > 'þ' outs(keyLig)

c U+0152 LATIN CAPITAL LIGATURE OE (d140 in ANSI)
'OE'                    + outs(keyLig) > 'Œ'
'Œ'                     + outs(keyLig) > 'OE' outs(keyLig)
'OE' outs(keyLig)       + outs(keyLig) > 'Œ' outs(keyLig)
c U+0153 LATIN SMALL LIGATURE OE (d156 in ANSI)
'oe'                    + outs(keyLig) > 'œ' 
'œ'                     + outs(keyLig) > 'oe' outs(keyLig)
'oe' outs(keyLig)       + outs(keyLig) > 'œ' outs(keyLig)  

c U+2020 DAGGER (d134 in ANSI)
'tt'                    + outs(keyLig) > '†' 
'†'                     + outs(keyLig) > 'tt' outs(keyLig)
'tt' outs(keyLig)       + outs(keyLig) > '†' outs(keyLig)
c U+2021 DOUBLE DAGGER (d135 in ANSI)
'TT'                    + outs(keyLig) > '‡' 
'‡'                     + outs(keyLig) > 'TT' outs(keyLig)
'TT' outs(keyLig)       + outs(keyLig) > '‡' outs(keyLig)
c U+2030 PER MILLE SIGN (d137 in ANSI)
'%0'                    + outs(keyLig) > '‰'
'‰'                     + outs(keyLig) > '%0' outs(keyLig)
'%0' outs(keyLig)       + outs(keyLig) > '‰' outs(keyLig)
c U+2039 SINGLE LEFT-POINTING ANGLE QUOTATION MARK (x8B in ANSI)
'<'                     + outs(keyLig) > '‹' 
'‹'                     + outs(keyLig) > '<' outs(keyLig)
'<' outs(keyLig)        + outs(keyLig) > '‹' outs(keyLig)
c U+203A SINGLE RIGHT-POINTING ANGLE QUOTATION MARK (x9B in ANSI)
'>'                     + outs(keyLig) > '›' 
'›'                     + outs(keyLig) > '>' outs(keyLig)
'>' outs(keyLig)        + outs(keyLig) > '›' outs(keyLig)
c U+2122 TRADEMARK SIGN (d153 in ANSI)
'TM'                    + outs(keyLig) > '™' 
'™'                     + outs(keyLig) > 'TM' outs(keyLig)
'TM' outs(keyLig)       + outs(keyLig) > '™' outs(keyLig)

c dashes and ellipsis
c                    
c PATCH AREA en dash: Optionally comment out the first line if you use two equals more often than en dash
'='     + '='           > d150          c en dash
'-n'    + outs(keyLig)  > d150          c en dash
'=='    + outs(keyLig)  > d150          c convert two equals to en dash
d150    + '='           > '=='          c convert en dash to two equals, start a line of equals
'=='    + '='           > context '='   c continue line of equals
c
c PATCH AREA em dash: Optionally comment out the first line if you use two hyphens more often than em dash
'-'     + '-'           > d151          c em dash
'-m'    + outs(keyLig)  > d151          c em dash
'--'    + outs(keyLig)  > d151          c convert two hyphens to em dash
d151    + '-'           > '--'          c convert em dash to two hyphens, start a line of hyphens
'--'    + '-'           > context '-'   c continue line of hyphens
c Special cases: don't convert -- to em dash in HTML comment
'<!-'   + '-'           > '<!--'        
d151    + '>'           > '-->'
c
c PATCH AREA ellipsis: optionally comment out the first line if you use three periods more often than ellipsis.
'..'    + '.'           > '…'           c ellipsis
'...'   + outs(keyLig)  > '…'           c convert three periods to ellipsis
'…'     + '/'           > '...'         c convert ellipsis to three periods; THIS IS AN ANOMOLOUS USE OF /, MAYBE USE | or keyLig
'…' '.' + '.'           > '.....'       c start a line of periods 
'...'   + '.'           > context '.'   c continue line of periods


c fractions
'¹/'        + '2' > '½' c 1/2
'¹/'        + '4' > '¼' c 1/4
'³/'        + '4' > '¾' c 3/4

c Currency symbols
any(baseCurr-A)               + outs(keyCurr)  > index(Curr-A,1)
any(Curr-A)                   + outs(keyCurr)  > index(baseCurr-A,1) outs(keyCurr)
any(baseCurr-A) outs(keyCurr) + outs(keyCurr)  > index(Curr-A,1) outs(keyCurr)

c Mathematical symbols
any(baseMath-A)               + outs(keyMath)  > index(Math-A,1)
any(Math-A)                   + outs(keyMath)  > index(baseMath-A,1) outs(keyMath)
any(baseMath-A) outs(keyMath) + outs(keyMath)  > index(Math-A,1) outs(keyMath)

c ========================================================================================================
c Line-breaking and control characters
                                                                       
+ [CTRL SHIFT " "]          > outs(nbsp)            c NO-BREAK SPACE
+ [SHIFT K_ENTER]           > [SHIFT K_ENTER]       c otherwise translated to U+000A LF
+ [CTRL K_BKSP]             > [CTRL K_BKSP]         c otherwise translated to U+007F DEL


